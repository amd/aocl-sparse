

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>AOCL-Sparse Level 1,2,3 Functions &#8212; AOCL-Sparse 4.2.0.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=ac02cc09edc035673794" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=ac02cc09edc035673794" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=ac02cc09edc035673794" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/rocm_header.css" />
    <link rel="stylesheet" type="text/css" href="_static/rocm_footer.css" />
    <link rel="stylesheet" type="text/css" href="_static/fonts.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=ac02cc09edc035673794"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://download.amd.com/js/analytics/analyticsinit.js"></script>
    <script async="async" src="_static/code_word_breaks.js"></script>
    <script async="async" src="_static/renameVersionLinks.js"></script>
    <script async="async" src="_static/rdcMisc.js"></script>
    <script async="async" src="_static/theme_mode_captions.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'functions';</script>
    <link rel="shortcut icon" href="https://www.amd.com/themes/custom/amd/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="AOCL-Sparse Iterative Linear System Solvers" href="solvers.html" />
    <link rel="prev" title="AOCL-Sparse Conversion Subprogram" href="convert.html" />
    <meta name="google-site-verification" content="ZOn0RZC0Pwzlmf2SaE0bRttWk1YzOhuslbpxUDchQ90" />

  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  

<header class="common-header" >
    <nav class="navbar navbar-expand-xl">
        <div class="container-fluid main-nav rocm-header">
            
            <div class="header-logo">
                <a class="navbar-brand" href="https://www.amd.com/">
                    <img src="_static/images/amd-header-logo.svg" alt="AMD Logo" title="AMD Logo" width="90" class="d-inline-block align-text-top hover-opacity"/>
                </a>
                <div class="vr vr mx-40 my-25"></div>
                <a class="klavika-font hover-opacity" href="/">AOCL</a>
            </div>
            <div class="icon-nav text-center d-flex ms-auto">
                <!-- TODO: Search icon up here maybe? -->
            </div>
        </div>
    </nav>
    
</header>

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    <p class="title logo__title">AOCL-Sparse 4.2.0.0 documentation</p>
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">AOCL APIs</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="analysis.html">AOCL-Sparse Analysis Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="auxiliary.html">AOCL-Sparse Auxiliary Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="convert.html">AOCL-Sparse Conversion Subprogram</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">AOCL-Sparse Level 1,2,3 Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="solvers.html">AOCL-Sparse Iterative Linear System Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">AOCL-Sparse Types</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-angle-right"></span>
  </label></div>
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page">AOCL-Sparse...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>AOCL-Sparse Level 1,2,3 Functions</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-1">Level 1</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-2">Level 2</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-3">Level 3</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#miscellaneous">Miscellaneous</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="aocl-sparse-level-1-2-3-functions">
<h1>AOCL-Sparse Level 1,2,3 Functions<a class="headerlink" href="#aocl-sparse-level-1-2-3-functions" title="Permalink to this heading">#</a></h1>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_functions.h</span></code> provides AMD CPU hardware optimized level 1, 2, and 3 Sparse Linear Algebra Subprograms (Sparse BLAS).</p>
<section id="level-1">
<h2>Level 1<a class="headerlink" href="#level-1" title="Permalink to this heading">#</a></h2>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_saxpyiK14aoclsparse_intKfPKfPK14aoclsparse_intPf">
<span id="_CPPv317aoclsparse_saxpyiK14aoclsparse_intKfPKfPK14aoclsparse_intPf"></span><span id="_CPPv217aoclsparse_saxpyiK14aoclsparse_intKfPKfPK14aoclsparse_intPf"></span><span id="aoclsparse_saxpyi__aoclsparse_intC.floatC.floatCP.aoclsparse_intCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a7fdbe9cb204494320f4709dd7b42e4a0"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_saxpyi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_saxpyiK14aoclsparse_intKfPKfPK14aoclsparse_intPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>A variant of sparse vector-vector addition between a compressed sparse vector and a dense vector. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)axpyi</span></code> adds a scalar multiple of compressed sparse vector to a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in C^m\)</span> be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = a*x_i + y_{I_{x_{i}}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>a</strong> – <strong>[in]</strong> Scalar value. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Sparse vector stored in compressed form of <span class="math notranslate nohighlight">\(nnz\)</span> elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Array should follow 0-based indexing. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_daxpyiK14aoclsparse_intKdPKdPK14aoclsparse_intPd">
<span id="_CPPv317aoclsparse_daxpyiK14aoclsparse_intKdPKdPK14aoclsparse_intPd"></span><span id="_CPPv217aoclsparse_daxpyiK14aoclsparse_intKdPKdPK14aoclsparse_intPd"></span><span id="aoclsparse_daxpyi__aoclsparse_intC.doubleC.doubleCP.aoclsparse_intCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a52162b710c876e4513b852193710b473"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_daxpyi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_daxpyiK14aoclsparse_intKdPKdPK14aoclsparse_intPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>A variant of sparse vector-vector addition between a compressed sparse vector and a dense vector. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)axpyi</span></code> adds a scalar multiple of compressed sparse vector to a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in C^m\)</span> be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = a*x_i + y_{I_{x_{i}}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>a</strong> – <strong>[in]</strong> Scalar value. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Sparse vector stored in compressed form of <span class="math notranslate nohighlight">\(nnz\)</span> elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Array should follow 0-based indexing. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_caxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv">
<span id="_CPPv317aoclsparse_caxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv"></span><span id="_CPPv217aoclsparse_caxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv"></span><span id="aoclsparse_caxpyi__aoclsparse_intC.voidCP.voidCP.aoclsparse_intCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1a626d85c0b849592bdc9c74fffc963b25"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_caxpyi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_caxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>A variant of sparse vector-vector addition between a compressed sparse vector and a dense vector. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)axpyi</span></code> adds a scalar multiple of compressed sparse vector to a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in C^m\)</span> be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = a*x_i + y_{I_{x_{i}}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>a</strong> – <strong>[in]</strong> Scalar value. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Sparse vector stored in compressed form of <span class="math notranslate nohighlight">\(nnz\)</span> elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Array should follow 0-based indexing. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zaxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv">
<span id="_CPPv317aoclsparse_zaxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv"></span><span id="_CPPv217aoclsparse_zaxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv"></span><span id="aoclsparse_zaxpyi__aoclsparse_intC.voidCP.voidCP.aoclsparse_intCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1a13ef2ea17077642cb4415f27bccb5b20"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zaxpyi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zaxpyiK14aoclsparse_intPKvPKvPK14aoclsparse_intPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>A variant of sparse vector-vector addition between a compressed sparse vector and a dense vector. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)axpyi</span></code> adds a scalar multiple of compressed sparse vector to a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in C^m\)</span> be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = a*x_i + y_{I_{x_{i}}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>a</strong> – <strong>[in]</strong> Scalar value. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Sparse vector stored in compressed form of <span class="math notranslate nohighlight">\(nnz\)</span> elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. Array should follow 0-based indexing. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_cdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv">
<span id="_CPPv317aoclsparse_cdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="_CPPv217aoclsparse_cdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="aoclsparse_cdotci__aoclsparse_intC.voidCP.aoclsparse_intCP.voidCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1aaffe860d2b703926e1140ace887e348d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cdotci</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_cdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse conjugate dot product for single and double data precision complex types. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_cdotci</span></code> (complex float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_zdotci</span></code> (complex double) compute the dot product of the conjugate of a complex vector stored in a compressed format and a complex dense vector. Let <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> be respectively a sparse and dense vectors in <span class="math notranslate nohighlight">\(C^m\)</span> with <code class="docutils literal notranslate"><span class="pre">indx</span></code> an indices vector of length at least <span class="math notranslate nohighlight">\(nnz\)</span> that is used to index into the entries of dense vector <span class="math notranslate nohighlight">\(y\)</span>, then these functions return</p>
<p><div class="math notranslate nohighlight">
\[ \text{dot} = \sum_{i=0}^{nnz-1} \text{conj}(x_i) * y_{indx_{i}}. \]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements (length) of vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> complex elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Vector of indices of length at least <span class="math notranslate nohighlight">\(nnz\)</span>. Each entry of this vector must contain a valid index into <span class="math notranslate nohighlight">\(y\)</span> and be unique. The entries of <code class="docutils literal notranslate"><span class="pre">indx</span></code> are not checked for validity. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> complex elements. </p></li>
<li><p><strong>dot</strong> – <strong>[out]</strong> The dot product of conjugate of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> when <span class="math notranslate nohighlight">\(nnz &gt; 0\)</span>. If <span class="math notranslate nohighlight">\(nnz \le 0\)</span>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is set to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that the provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv">
<span id="_CPPv317aoclsparse_zdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="_CPPv217aoclsparse_zdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="aoclsparse_zdotci__aoclsparse_intC.voidCP.aoclsparse_intCP.voidCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1aa1736ddd98497dcd23ced575a7c1c09f"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zdotci</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zdotciK14aoclsparse_intPKvPK14aoclsparse_intPKvPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse conjugate dot product for single and double data precision complex types. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_cdotci</span></code> (complex float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_zdotci</span></code> (complex double) compute the dot product of the conjugate of a complex vector stored in a compressed format and a complex dense vector. Let <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> be respectively a sparse and dense vectors in <span class="math notranslate nohighlight">\(C^m\)</span> with <code class="docutils literal notranslate"><span class="pre">indx</span></code> an indices vector of length at least <span class="math notranslate nohighlight">\(nnz\)</span> that is used to index into the entries of dense vector <span class="math notranslate nohighlight">\(y\)</span>, then these functions return</p>
<p><div class="math notranslate nohighlight">
\[ \text{dot} = \sum_{i=0}^{nnz-1} \text{conj}(x_i) * y_{indx_{i}}. \]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements (length) of vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> complex elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Vector of indices of length at least <span class="math notranslate nohighlight">\(nnz\)</span>. Each entry of this vector must contain a valid index into <span class="math notranslate nohighlight">\(y\)</span> and be unique. The entries of <code class="docutils literal notranslate"><span class="pre">indx</span></code> are not checked for validity. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> complex elements. </p></li>
<li><p><strong>dot</strong> – <strong>[out]</strong> The dot product of conjugate of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> when <span class="math notranslate nohighlight">\(nnz &gt; 0\)</span>. If <span class="math notranslate nohighlight">\(nnz \le 0\)</span>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is set to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that the provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_cdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv">
<span id="_CPPv317aoclsparse_cdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="_CPPv217aoclsparse_cdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="aoclsparse_cdotui__aoclsparse_intC.voidCP.aoclsparse_intCP.voidCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1a098a524ae0ef6fae7bff23d3bdb81a2c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cdotui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_cdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse dot product for single and double data precision complex types. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_cdotui</span></code> (complex float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_zdotui</span></code> (complex double) compute the dot product of a complex vector stored in a compressed format and a complex dense vector. Let <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> be respectively a sparse and dense vectors in <span class="math notranslate nohighlight">\(C^m\)</span> with <code class="docutils literal notranslate"><span class="pre">indx</span></code> an indices vector of length at least <span class="math notranslate nohighlight">\(nnz\)</span> that is used to index into the entries of dense vector <span class="math notranslate nohighlight">\(y\)</span>, then these functions return</p>
<p><div class="math notranslate nohighlight">
\[ \text{dot} = \sum_{i=0}^{nnz-1} x_{i} * y_{indx_{i}}. \]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements (length) of vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> complex elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Vector of indices of length at least <span class="math notranslate nohighlight">\(nnz\)</span>. Each entry of this vector must contain a valid index into <span class="math notranslate nohighlight">\(y\)</span> and be unique. The entries of <code class="docutils literal notranslate"><span class="pre">indx</span></code> are not checked for validity. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> complex elements. </p></li>
<li><p><strong>dot</strong> – <strong>[out]</strong> The dot product of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> when <span class="math notranslate nohighlight">\(nnz &gt; 0\)</span>. If <span class="math notranslate nohighlight">\(nnz \le 0\)</span>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is set to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that the provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv">
<span id="_CPPv317aoclsparse_zdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="_CPPv217aoclsparse_zdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv"></span><span id="aoclsparse_zdotui__aoclsparse_intC.voidCP.aoclsparse_intCP.voidCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1a43a2089136193c23a59607d774da2241"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zdotui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dot</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zdotuiK14aoclsparse_intPKvPK14aoclsparse_intPKvPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse dot product for single and double data precision complex types. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_cdotui</span></code> (complex float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_zdotui</span></code> (complex double) compute the dot product of a complex vector stored in a compressed format and a complex dense vector. Let <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> be respectively a sparse and dense vectors in <span class="math notranslate nohighlight">\(C^m\)</span> with <code class="docutils literal notranslate"><span class="pre">indx</span></code> an indices vector of length at least <span class="math notranslate nohighlight">\(nnz\)</span> that is used to index into the entries of dense vector <span class="math notranslate nohighlight">\(y\)</span>, then these functions return</p>
<p><div class="math notranslate nohighlight">
\[ \text{dot} = \sum_{i=0}^{nnz-1} x_{i} * y_{indx_{i}}. \]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements (length) of vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> complex elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Vector of indices of length at least <span class="math notranslate nohighlight">\(nnz\)</span>. Each entry of this vector must contain a valid index into <span class="math notranslate nohighlight">\(y\)</span> and be unique. The entries of <code class="docutils literal notranslate"><span class="pre">indx</span></code> are not checked for validity. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> complex elements. </p></li>
<li><p><strong>dot</strong> – <strong>[out]</strong> The dot product of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> when <span class="math notranslate nohighlight">\(nnz &gt; 0\)</span>. If <span class="math notranslate nohighlight">\(nnz \le 0\)</span>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is set to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">dot</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that the provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_sdotiK14aoclsparse_intPKfPK14aoclsparse_intPKf">
<span id="_CPPv316aoclsparse_sdotiK14aoclsparse_intPKfPK14aoclsparse_intPKf"></span><span id="_CPPv216aoclsparse_sdotiK14aoclsparse_intPKfPK14aoclsparse_intPKf"></span><span id="aoclsparse_sdoti__aoclsparse_intC.floatCP.aoclsparse_intCP.floatCP"></span><span class="target" id="aoclsparse__functions_8h_1af1095d97937f1c589721793f4a54aa13"></span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sdoti</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_sdotiK14aoclsparse_intPKfPK14aoclsparse_intPKf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse dot product for single and double data precision real types. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_sdoti</span></code> (float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_ddoti</span></code> (double) compute the dot product of a real vector stored in a compressed format and a real dense vector. Let <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> be respectively a sparse and dense vectors in <span class="math notranslate nohighlight">\(R^m\)</span> with <code class="docutils literal notranslate"><span class="pre">indx</span></code> an indices vector of length at least <span class="math notranslate nohighlight">\(nnz\)</span> that is used to index into the entries of dense vector <span class="math notranslate nohighlight">\(y\)</span>, then these functions return</p>
<p><div class="math notranslate nohighlight">
\[ \text{dot} = \sum_{i=0}^{nnz-1} x_{i} * y_{indx_{i}}. \]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements (length) of vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> real elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Vector of indices of length at least <span class="math notranslate nohighlight">\(nnz\)</span>. Each entry of this vector must contain a valid index into <span class="math notranslate nohighlight">\(y\)</span> and be unique. The entries of <code class="docutils literal notranslate"><span class="pre">indx</span></code> are not checked for validity. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> complex elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><p><strong>Float/double</strong> – Value of the dot product if <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is positive, otherwise it is set to 0. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_ddotiK14aoclsparse_intPKdPK14aoclsparse_intPKd">
<span id="_CPPv316aoclsparse_ddotiK14aoclsparse_intPKdPK14aoclsparse_intPKd"></span><span id="_CPPv216aoclsparse_ddotiK14aoclsparse_intPKdPK14aoclsparse_intPKd"></span><span id="aoclsparse_ddoti__aoclsparse_intC.doubleCP.aoclsparse_intCP.doubleCP"></span><span class="target" id="aoclsparse__functions_8h_1a160b5ab01042a1a630dc8b66caaa5e1e"></span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ddoti</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_ddotiK14aoclsparse_intPKdPK14aoclsparse_intPKd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse dot product for single and double data precision real types. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_sdoti</span></code> (float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_ddoti</span></code> (double) compute the dot product of a real vector stored in a compressed format and a real dense vector. Let <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> be respectively a sparse and dense vectors in <span class="math notranslate nohighlight">\(R^m\)</span> with <code class="docutils literal notranslate"><span class="pre">indx</span></code> an indices vector of length at least <span class="math notranslate nohighlight">\(nnz\)</span> that is used to index into the entries of dense vector <span class="math notranslate nohighlight">\(y\)</span>, then these functions return</p>
<p><div class="math notranslate nohighlight">
\[ \text{dot} = \sum_{i=0}^{nnz-1} x_{i} * y_{indx_{i}}. \]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements (length) of vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> real elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Vector of indices of length at least <span class="math notranslate nohighlight">\(nnz\)</span>. Each entry of this vector must contain a valid index into <span class="math notranslate nohighlight">\(y\)</span> and be unique. The entries of <code class="docutils literal notranslate"><span class="pre">indx</span></code> are not checked for validity. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> complex elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><p><strong>Float/double</strong> – Value of the dot product if <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is positive, otherwise it is set to 0. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_ssctrK14aoclsparse_intPKfPK14aoclsparse_intPf">
<span id="_CPPv316aoclsparse_ssctrK14aoclsparse_intPKfPK14aoclsparse_intPf"></span><span id="_CPPv216aoclsparse_ssctrK14aoclsparse_intPKfPK14aoclsparse_intPf"></span><span id="aoclsparse_ssctr__aoclsparse_intC.floatCP.aoclsparse_intCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1af49b7fb2155de9693210ee6628b1142f"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ssctr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_ssctrK14aoclsparse_intPKfPK14aoclsparse_intPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter for single and double precision real and complex types. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctr+\)</span> scatter the elements of a compressed sparse vector into a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = x_i, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_dsctrK14aoclsparse_intPKdPK14aoclsparse_intPd">
<span id="_CPPv316aoclsparse_dsctrK14aoclsparse_intPKdPK14aoclsparse_intPd"></span><span id="_CPPv216aoclsparse_dsctrK14aoclsparse_intPKdPK14aoclsparse_intPd"></span><span id="aoclsparse_dsctr__aoclsparse_intC.doubleCP.aoclsparse_intCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1ae42de2fc7103e5532fce735c5c6f329c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dsctr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_dsctrK14aoclsparse_intPKdPK14aoclsparse_intPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter for single and double precision real and complex types. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctr+\)</span> scatter the elements of a compressed sparse vector into a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = x_i, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_csctrK14aoclsparse_intPKvPK14aoclsparse_intPv">
<span id="_CPPv316aoclsparse_csctrK14aoclsparse_intPKvPK14aoclsparse_intPv"></span><span id="_CPPv216aoclsparse_csctrK14aoclsparse_intPKvPK14aoclsparse_intPv"></span><span id="aoclsparse_csctr__aoclsparse_intC.voidCP.aoclsparse_intCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1aff859836d17223e8b60300caa7afd023"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_csctr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_csctrK14aoclsparse_intPKvPK14aoclsparse_intPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter for single and double precision real and complex types. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctr+\)</span> scatter the elements of a compressed sparse vector into a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = x_i, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_zsctrK14aoclsparse_intPKvPK14aoclsparse_intPv">
<span id="_CPPv316aoclsparse_zsctrK14aoclsparse_intPKvPK14aoclsparse_intPv"></span><span id="_CPPv216aoclsparse_zsctrK14aoclsparse_intPKvPK14aoclsparse_intPv"></span><span id="aoclsparse_zsctr__aoclsparse_intC.voidCP.aoclsparse_intCP.voidP"></span><span class="target" id="aoclsparse__functions_8h_1aadd644633fd8ba7ef741500a17c3e825"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zsctr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_zsctrK14aoclsparse_intPKvPK14aoclsparse_intPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter for single and double precision real and complex types. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctr+\)</span> scatter the elements of a compressed sparse vector into a dense vector.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = x_i, i\in\{1,\ldots,\text{nnz}\}. \]</div>
</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements to be scattered. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_ssctrsK14aoclsparse_intPKf14aoclsparse_intPf">
<span id="_CPPv317aoclsparse_ssctrsK14aoclsparse_intPKf14aoclsparse_intPf"></span><span id="_CPPv217aoclsparse_ssctrsK14aoclsparse_intPKf14aoclsparse_intPf"></span><span id="aoclsparse_ssctrs__aoclsparse_intC.floatCP.aoclsparse_int.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a14196873e4cfda286447faf505d92df4"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ssctrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_ssctrsK14aoclsparse_intPKf14aoclsparse_intPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter with stride for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctrs+\)</span> scatters the elements of a compressed sparse vector into a dense vector using a stride.</p>
<p>Let <span class="math notranslate nohighlight">\(y\)</span> be a dense vector of length <span class="math notranslate nohighlight">\(n&gt;0\)</span>, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector with <code class="docutils literal notranslate"><span class="pre">nnz</span></code> &gt; 0 nonzeros, and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a striding distance, then <span class="math notranslate nohighlight">\( y_{\text{stride} \times i} = x_i,\quad i\in\{1,\ldots,\text{nnz}\}.\)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contents of the vector <code class="docutils literal notranslate"><span class="pre">x</span></code> are accessed but not checked.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of nonzero elements in <span class="math notranslate nohighlight">\(x\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements to be scattered into <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> (Positive) striding distance used to store elements in vector <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of size at least <code class="docutils literal notranslate"><span class="pre">stride</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that one or more of the values provided in <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or <code class="docutils literal notranslate"><span class="pre">stride</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dsctrsK14aoclsparse_intPKd14aoclsparse_intPd">
<span id="_CPPv317aoclsparse_dsctrsK14aoclsparse_intPKd14aoclsparse_intPd"></span><span id="_CPPv217aoclsparse_dsctrsK14aoclsparse_intPKd14aoclsparse_intPd"></span><span id="aoclsparse_dsctrs__aoclsparse_intC.doubleCP.aoclsparse_int.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a93f6662ff1b6a500b656ed1878540d23"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dsctrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dsctrsK14aoclsparse_intPKd14aoclsparse_intPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter with stride for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctrs+\)</span> scatters the elements of a compressed sparse vector into a dense vector using a stride.</p>
<p>Let <span class="math notranslate nohighlight">\(y\)</span> be a dense vector of length <span class="math notranslate nohighlight">\(n&gt;0\)</span>, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector with <code class="docutils literal notranslate"><span class="pre">nnz</span></code> &gt; 0 nonzeros, and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a striding distance, then <span class="math notranslate nohighlight">\( y_{\text{stride} \times i} = x_i,\quad i\in\{1,\ldots,\text{nnz}\}.\)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contents of the vector <code class="docutils literal notranslate"><span class="pre">x</span></code> are accessed but not checked.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of nonzero elements in <span class="math notranslate nohighlight">\(x\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements to be scattered into <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> (Positive) striding distance used to store elements in vector <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of size at least <code class="docutils literal notranslate"><span class="pre">stride</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that one or more of the values provided in <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or <code class="docutils literal notranslate"><span class="pre">stride</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_csctrsK14aoclsparse_intPKv14aoclsparse_intPv">
<span id="_CPPv317aoclsparse_csctrsK14aoclsparse_intPKv14aoclsparse_intPv"></span><span id="_CPPv217aoclsparse_csctrsK14aoclsparse_intPKv14aoclsparse_intPv"></span><span id="aoclsparse_csctrs__aoclsparse_intC.voidCP.aoclsparse_int.voidP"></span><span class="target" id="aoclsparse__functions_8h_1a37486b126a93f1f3398f5e2e46db0732"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_csctrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_csctrsK14aoclsparse_intPKv14aoclsparse_intPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter with stride for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctrs+\)</span> scatters the elements of a compressed sparse vector into a dense vector using a stride.</p>
<p>Let <span class="math notranslate nohighlight">\(y\)</span> be a dense vector of length <span class="math notranslate nohighlight">\(n&gt;0\)</span>, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector with <code class="docutils literal notranslate"><span class="pre">nnz</span></code> &gt; 0 nonzeros, and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a striding distance, then <span class="math notranslate nohighlight">\( y_{\text{stride} \times i} = x_i,\quad i\in\{1,\ldots,\text{nnz}\}.\)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contents of the vector <code class="docutils literal notranslate"><span class="pre">x</span></code> are accessed but not checked.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of nonzero elements in <span class="math notranslate nohighlight">\(x\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements to be scattered into <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> (Positive) striding distance used to store elements in vector <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of size at least <code class="docutils literal notranslate"><span class="pre">stride</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that one or more of the values provided in <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or <code class="docutils literal notranslate"><span class="pre">stride</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zsctrsK14aoclsparse_intPKv14aoclsparse_intPv">
<span id="_CPPv317aoclsparse_zsctrsK14aoclsparse_intPKv14aoclsparse_intPv"></span><span id="_CPPv217aoclsparse_zsctrsK14aoclsparse_intPKv14aoclsparse_intPv"></span><span id="aoclsparse_zsctrs__aoclsparse_intC.voidCP.aoclsparse_int.voidP"></span><span class="target" id="aoclsparse__functions_8h_1a35c1db3c72a376651a92f81fe56eafe1"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zsctrs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zsctrsK14aoclsparse_intPKv14aoclsparse_intPv" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse scatter with stride for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?sctrs+\)</span> scatters the elements of a compressed sparse vector into a dense vector using a stride.</p>
<p>Let <span class="math notranslate nohighlight">\(y\)</span> be a dense vector of length <span class="math notranslate nohighlight">\(n&gt;0\)</span>, <span class="math notranslate nohighlight">\(x\)</span> be a compressed sparse vector with <code class="docutils literal notranslate"><span class="pre">nnz</span></code> &gt; 0 nonzeros, and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a striding distance, then <span class="math notranslate nohighlight">\( y_{\text{stride} \times i} = x_i,\quad i\in\{1,\ldots,\text{nnz}\}.\)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contents of the vector <code class="docutils literal notranslate"><span class="pre">x</span></code> are accessed but not checked.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of nonzero elements in <span class="math notranslate nohighlight">\(x\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> Array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements to be scattered into <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> (Positive) striding distance used to store elements in vector <code class="docutils literal notranslate"><span class="pre">y</span></code>. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> Array of size at least <code class="docutils literal notranslate"><span class="pre">stride</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that one or more of the values provided in <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or <code class="docutils literal notranslate"><span class="pre">stride</span></code> is not positive. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_srotiK14aoclsparse_intPfPK14aoclsparse_intPfKfKf">
<span id="_CPPv316aoclsparse_srotiK14aoclsparse_intPfPK14aoclsparse_intPfKfKf"></span><span id="_CPPv216aoclsparse_srotiK14aoclsparse_intPfPK14aoclsparse_intPfKfKf"></span><span id="aoclsparse_sroti__aoclsparse_intC.floatP.aoclsparse_intCP.floatP.floatC.floatC"></span><span class="target" id="aoclsparse__functions_8h_1af2e204b5ba768e72883964e19126938d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sroti</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_srotiK14aoclsparse_intPfPK14aoclsparse_intPfKfKf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Applies Givens rotations to single and double precision real vectors. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_sroti</span></code> (float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_droti</span></code> (double) apply the Givens rotations on elements of two real vectors.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> be a vector in full storage form, <span class="math notranslate nohighlight">\(x\)</span> be a vector in a compressed form and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ x_i = c * x_i + s * y_{I_{x_{i}}} \]</div>
 <div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = c * y_{I_{x_{i}}} - s * x_i \]</div>
</p>
<p>where <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> are scalars.</p>
<p>A possible C implementation could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> elements in compressed form. The elements of the array are updated after applying Givens rotation. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements used for Givens rotation. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code> and are distinct. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements in full storage form. The elements of the array are updated after applying Givens rotation. </p></li>
<li><p><strong>c</strong> – <strong>[in]</strong> A scalar. </p></li>
<li><p><strong>s</strong> – <strong>[in]</strong> A scalar.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. With this error, the values of vectors x and y are undefined. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_drotiK14aoclsparse_intPdPK14aoclsparse_intPdKdKd">
<span id="_CPPv316aoclsparse_drotiK14aoclsparse_intPdPK14aoclsparse_intPdKdKd"></span><span id="_CPPv216aoclsparse_drotiK14aoclsparse_intPdPK14aoclsparse_intPdKdKd"></span><span id="aoclsparse_droti__aoclsparse_intC.doubleP.aoclsparse_intCP.doubleP.doubleC.doubleC"></span><span class="target" id="aoclsparse__functions_8h_1abcf766bee9ffcd7b577763c780efdb8d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_droti</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_drotiK14aoclsparse_intPdPK14aoclsparse_intPdKdKd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Applies Givens rotations to single and double precision real vectors. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_sroti</span></code> (float) and <code class="docutils literal notranslate"><span class="pre">aoclsparse_droti</span></code> (double) apply the Givens rotations on elements of two real vectors.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> be a vector in full storage form, <span class="math notranslate nohighlight">\(x\)</span> be a vector in a compressed form and <span class="math notranslate nohighlight">\(I_x\)</span> be an indices vector of length at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then</p>
<p><div class="math notranslate nohighlight">
\[ x_i = c * x_i + s * y_{I_{x_{i}}} \]</div>
 <div class="math notranslate nohighlight">
\[ y_{I_{x_{i}}} = c * y_{I_{x_{i}}} - s * x_i \]</div>
</p>
<p>where <code class="docutils literal notranslate"><span class="pre">c</span></code>, <code class="docutils literal notranslate"><span class="pre">s</span></code> are scalars.</p>
<p>A possible C implementation could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The contents of the vectors are not checked for NaNs.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> The number of elements in <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(indx\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(nnz\)</span> elements in compressed form. The elements of the array are updated after applying Givens rotation. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> Indices of <span class="math notranslate nohighlight">\(nnz\)</span> elements used for Givens rotation. The elements in this vector are only checked for non-negativity. The user should make sure that index is less than the size of <code class="docutils literal notranslate"><span class="pre">y</span></code> and are distinct. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> Array of at least <span class="math notranslate nohighlight">\(\max(indx_i, i \in \{ 1,\ldots,nnz\})\)</span> elements in full storage form. The elements of the array are updated after applying Givens rotation. </p></li>
<li><p><strong>c</strong> – <strong>[in]</strong> A scalar. </p></li>
<li><p><strong>s</strong> – <strong>[in]</strong> A scalar.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – At least one of the pointers <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">indx</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – Indicates that provided <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is less than zero. </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – At least one of the indices in indx is negative. With this error, the values of vectors x and y are undefined. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_sgthr14aoclsparse_intPKfPfPK14aoclsparse_int">
<span id="_CPPv316aoclsparse_sgthr14aoclsparse_intPKfPfPK14aoclsparse_int"></span><span id="_CPPv216aoclsparse_sgthr14aoclsparse_intPKfPfPK14aoclsparse_int"></span><span id="aoclsparse_sgthr__aoclsparse_int.floatCP.floatP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1a3f49b1679170abbced236102d30ac9bb"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sgthr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_sgthr14aoclsparse_intPKfPfPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> is a group of functions that gather the elements indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthr</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthr</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_dgthr14aoclsparse_intPKdPdPK14aoclsparse_int">
<span id="_CPPv316aoclsparse_dgthr14aoclsparse_intPKdPdPK14aoclsparse_int"></span><span id="_CPPv216aoclsparse_dgthr14aoclsparse_intPKdPdPK14aoclsparse_int"></span><span id="aoclsparse_dgthr__aoclsparse_int.doubleCP.doubleP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1ad8b8b98afec508c468f220da735a72ac"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dgthr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_dgthr14aoclsparse_intPKdPdPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> is a group of functions that gather the elements indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthr</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthr</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_cgthr14aoclsparse_intPKvPvPK14aoclsparse_int">
<span id="_CPPv316aoclsparse_cgthr14aoclsparse_intPKvPvPK14aoclsparse_int"></span><span id="_CPPv216aoclsparse_cgthr14aoclsparse_intPKvPvPK14aoclsparse_int"></span><span id="aoclsparse_cgthr__aoclsparse_int.voidCP.voidP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1aaf897cdd523be645a0029388ce1eddf9"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cgthr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_cgthr14aoclsparse_intPKvPvPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> is a group of functions that gather the elements indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthr</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthr</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_zgthr14aoclsparse_intPKvPvPK14aoclsparse_int">
<span id="_CPPv316aoclsparse_zgthr14aoclsparse_intPKvPvPK14aoclsparse_int"></span><span id="_CPPv216aoclsparse_zgthr14aoclsparse_intPKvPvPK14aoclsparse_int"></span><span id="aoclsparse_zgthr__aoclsparse_int.voidCP.voidP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1a6eb11ede5e6e94da2e8505f9efb847f7"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zgthr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_zgthr14aoclsparse_intPKvPvPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> is a group of functions that gather the elements indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthr</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthr</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_sgthrz14aoclsparse_intPfPfPK14aoclsparse_int">
<span id="_CPPv317aoclsparse_sgthrz14aoclsparse_intPfPfPK14aoclsparse_int"></span><span id="_CPPv217aoclsparse_sgthrz14aoclsparse_intPfPfPK14aoclsparse_int"></span><span id="aoclsparse_sgthrz__aoclsparse_int.floatP.floatP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1a93bc25c63c91d5b5b3d592d784ebbed3"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sgthrz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_sgthrz14aoclsparse_intPfPfPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather and zero out elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrz+\)</span> is a group of functions that gather the elements</p>
<p>indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>. The gathered elements in <span class="math notranslate nohighlight">\(y\)</span> are replaced by zero.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}, \text{ and after the assignment, } y_{I_{x_i}}=0, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthrz</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthrz</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dgthrz14aoclsparse_intPdPdPK14aoclsparse_int">
<span id="_CPPv317aoclsparse_dgthrz14aoclsparse_intPdPdPK14aoclsparse_int"></span><span id="_CPPv217aoclsparse_dgthrz14aoclsparse_intPdPdPK14aoclsparse_int"></span><span id="aoclsparse_dgthrz__aoclsparse_int.doubleP.doubleP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1afe35dc23e2ca28e07a3048e78f34b836"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dgthrz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dgthrz14aoclsparse_intPdPdPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather and zero out elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrz+\)</span> is a group of functions that gather the elements</p>
<p>indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>. The gathered elements in <span class="math notranslate nohighlight">\(y\)</span> are replaced by zero.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}, \text{ and after the assignment, } y_{I_{x_i}}=0, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthrz</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthrz</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_cgthrz14aoclsparse_intPvPvPK14aoclsparse_int">
<span id="_CPPv317aoclsparse_cgthrz14aoclsparse_intPvPvPK14aoclsparse_int"></span><span id="_CPPv217aoclsparse_cgthrz14aoclsparse_intPvPvPK14aoclsparse_int"></span><span id="aoclsparse_cgthrz__aoclsparse_int.voidP.voidP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1a4c9dba1520dcd3f52914fc312b16d4e0"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cgthrz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_cgthrz14aoclsparse_intPvPvPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather and zero out elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrz+\)</span> is a group of functions that gather the elements</p>
<p>indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>. The gathered elements in <span class="math notranslate nohighlight">\(y\)</span> are replaced by zero.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}, \text{ and after the assignment, } y_{I_{x_i}}=0, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthrz</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthrz</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zgthrz14aoclsparse_intPvPvPK14aoclsparse_int">
<span id="_CPPv317aoclsparse_zgthrz14aoclsparse_intPvPvPK14aoclsparse_int"></span><span id="_CPPv217aoclsparse_zgthrz14aoclsparse_intPvPvPK14aoclsparse_int"></span><span id="aoclsparse_zgthrz__aoclsparse_int.voidP.voidP.aoclsparse_intCP"></span><span class="target" id="aoclsparse__functions_8h_1ac3a3089bd9b8ccc2c6b3c5d484b40538"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zgthrz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">indx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zgthrz14aoclsparse_intPvPvPK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather and zero out elements from a dense vector and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrz+\)</span> is a group of functions that gather the elements</p>
<p>indexed in <code class="docutils literal notranslate"><span class="pre">indx</span></code> from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>. The gathered elements in <span class="math notranslate nohighlight">\(y\)</span> are replaced by zero.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <span class="math notranslate nohighlight">\(I_x\)</span> be a set of indices of size <span class="math notranslate nohighlight">\(0&lt;\)</span> <code class="docutils literal notranslate"><span class="pre">nnz</span></code> <span class="math notranslate nohighlight">\(\le m\)</span> described by <code class="docutils literal notranslate"><span class="pre">indx</span></code>, then <div class="math notranslate nohighlight">
\[ x_i = y_{I_{x_i}}, i\in\{1,\ldots,\text{nnz}\}, \text{ and after the assignment, } y_{I_{x_i}}=0, i\in\{1,\ldots,\text{nnz}\}. \]</div>
 For double precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_zgthrz</span></code> and for single precision complex vectors use <code class="docutils literal notranslate"><span class="pre">aoclsparse_cgthrz</span></code>.</p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
<span class="w">   </span><span class="n">y</span><span class="p">[</span><span class="n">indx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions assume that the indices stored in <code class="docutils literal notranslate"><span class="pre">indx</span></code> are less than <span class="math notranslate nohighlight">\(m\)</span> without duplicate elements, and that <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are pointers to vectors of size at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code>. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, and <code class="docutils literal notranslate"><span class="pre">indx</span></code> are touched. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>indx</strong> – <strong>[in]</strong> index vector of size <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, containing the indices of the non-zero values of <span class="math notranslate nohighlight">\(x\)</span>. Indices should range from 0 to <span class="math notranslate nohighlight">\(m-1\)</span>, need not be ordered. The elements in this vector are only checked for non-negativity. The user should make sure that no index is out-of-bound and that it does not contains any duplicates.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">nnz</span></code> parameter value is negative </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">indx</span></code> is invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_index_value</strong> – at least one of the indices in <code class="docutils literal notranslate"><span class="pre">indx</span></code> is negative </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_sgthrs14aoclsparse_intPKfPf14aoclsparse_int">
<span id="_CPPv317aoclsparse_sgthrs14aoclsparse_intPKfPf14aoclsparse_int"></span><span id="_CPPv217aoclsparse_sgthrs14aoclsparse_intPKfPf14aoclsparse_int"></span><span id="aoclsparse_sgthrs__aoclsparse_int.floatCP.floatP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a5a337bc567688e2941e66ae02c2d4bcb"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sgthrs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_sgthrs14aoclsparse_intPKfPf14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector using a stride and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrs+\)</span> is a group of functions that gather the elements from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> using a fixed stride distance and copies them into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a (positive) striding distance, then <span class="math notranslate nohighlight">\( x_i = y_{\text{stride} \times i}, \quad i\in\{1,\ldots,\text{nnz}\}. \)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions are taylored for the case where <code class="docutils literal notranslate"><span class="pre">stride</span></code> is greater than 1. If stride is 1, then it is recommended to use the <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> set of functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are accessed. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> Pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> Striding distance used to access elements in the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – either <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or the <code class="docutils literal notranslate"><span class="pre">stride</span></code> parameter values are not positive. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, or <code class="docutils literal notranslate"><span class="pre">x</span></code> is invalid. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dgthrs14aoclsparse_intPKdPd14aoclsparse_int">
<span id="_CPPv317aoclsparse_dgthrs14aoclsparse_intPKdPd14aoclsparse_int"></span><span id="_CPPv217aoclsparse_dgthrs14aoclsparse_intPKdPd14aoclsparse_int"></span><span id="aoclsparse_dgthrs__aoclsparse_int.doubleCP.doubleP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1ae90382dbba4f7ad27bb472bf037eac9c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dgthrs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dgthrs14aoclsparse_intPKdPd14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector using a stride and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrs+\)</span> is a group of functions that gather the elements from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> using a fixed stride distance and copies them into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a (positive) striding distance, then <span class="math notranslate nohighlight">\( x_i = y_{\text{stride} \times i}, \quad i\in\{1,\ldots,\text{nnz}\}. \)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions are taylored for the case where <code class="docutils literal notranslate"><span class="pre">stride</span></code> is greater than 1. If stride is 1, then it is recommended to use the <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> set of functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are accessed. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> Pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> Striding distance used to access elements in the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – either <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or the <code class="docutils literal notranslate"><span class="pre">stride</span></code> parameter values are not positive. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, or <code class="docutils literal notranslate"><span class="pre">x</span></code> is invalid. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_cgthrs14aoclsparse_intPKvPv14aoclsparse_int">
<span id="_CPPv317aoclsparse_cgthrs14aoclsparse_intPKvPv14aoclsparse_int"></span><span id="_CPPv217aoclsparse_cgthrs14aoclsparse_intPKvPv14aoclsparse_int"></span><span id="aoclsparse_cgthrs__aoclsparse_int.voidCP.voidP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1ab1d2a060c9c5b01532a4a396ca1d0986"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cgthrs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_cgthrs14aoclsparse_intPKvPv14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector using a stride and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrs+\)</span> is a group of functions that gather the elements from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> using a fixed stride distance and copies them into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a (positive) striding distance, then <span class="math notranslate nohighlight">\( x_i = y_{\text{stride} \times i}, \quad i\in\{1,\ldots,\text{nnz}\}. \)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions are taylored for the case where <code class="docutils literal notranslate"><span class="pre">stride</span></code> is greater than 1. If stride is 1, then it is recommended to use the <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> set of functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are accessed. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> Pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> Striding distance used to access elements in the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – either <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or the <code class="docutils literal notranslate"><span class="pre">stride</span></code> parameter values are not positive. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, or <code class="docutils literal notranslate"><span class="pre">x</span></code> is invalid. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zgthrs14aoclsparse_intPKvPv14aoclsparse_int">
<span id="_CPPv317aoclsparse_zgthrs14aoclsparse_intPKvPv14aoclsparse_int"></span><span id="_CPPv217aoclsparse_zgthrs14aoclsparse_intPKvPv14aoclsparse_int"></span><span id="aoclsparse_zgthrs__aoclsparse_int.voidCP.voidP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a68552f1f31d372fe4ca555ec76d053a9"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zgthrs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">stride</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zgthrs14aoclsparse_intPKvPv14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Gather elements from a dense vector using a stride and store them into a sparse vector. </p>
<p>The <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthrs+\)</span> is a group of functions that gather the elements from the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code> using a fixed stride distance and copies them into the sparse vector <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Let <span class="math notranslate nohighlight">\(y\in R^m\)</span> (or <span class="math notranslate nohighlight">\(C^m\)</span>) be a dense vector, <span class="math notranslate nohighlight">\(x\)</span> be a sparse vector from the same space and <code class="docutils literal notranslate"><span class="pre">stride</span></code> be a (positive) striding distance, then <span class="math notranslate nohighlight">\( x_i = y_{\text{stride} \times i}, \quad i\in\{1,\ldots,\text{nnz}\}. \)</span></p>
<p>A possible C implementation for real vectors could be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnz</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">   </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[</span><span class="n">stride</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">];</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>These functions are taylored for the case where <code class="docutils literal notranslate"><span class="pre">stride</span></code> is greater than 1. If stride is 1, then it is recommended to use the <span class="math notranslate nohighlight">\(\verb+aoclsparse_?gthr+\)</span> set of functions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nnz</strong> – <strong>[in]</strong> Number of non-zero entries of <span class="math notranslate nohighlight">\(x\)</span>. If <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is zero, then none of the entries of vectors <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are accessed. </p></li>
<li><p><strong>y</strong> – <strong>[in]</strong> Pointer to dense vector <span class="math notranslate nohighlight">\(y\)</span> of size at least <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> Pointer to sparse vector <span class="math notranslate nohighlight">\(x\)</span> with at least <code class="docutils literal notranslate"><span class="pre">nnz</span></code> non-zero elements. </p></li>
<li><p><strong>stride</strong> – <strong>[in]</strong> Striding distance used to access elements in the dense vector <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – either <code class="docutils literal notranslate"><span class="pre">nnz</span></code> or the <code class="docutils literal notranslate"><span class="pre">stride</span></code> parameter values are not positive. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – at least one of the pointers <code class="docutils literal notranslate"><span class="pre">y</span></code>, or <code class="docutils literal notranslate"><span class="pre">x</span></code> is invalid. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="level-2">
<h2>Level 2<a class="headerlink" href="#level-2" title="Permalink to this heading">#</a></h2>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_scsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf">
<span id="_CPPv317aoclsparse_scsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="_CPPv217aoclsparse_scsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="aoclsparse_scsrmv__aoclsparse_operation.floatCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.floatCP.aoclsparse_intCP.aoclsparse_intCP.aoclsparse_mat_descrC.floatCP.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a10ef7aa6c10ff8f80a9afdc9cb1f41c0"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_scsrmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_col_ind</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_row_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_scsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single and double precision sparse matrix vector multiplication using CSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_csrmv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in CSR storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans = aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans = aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans = aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p><dl class="simple">
<dt><strong>Example</strong></dt><dd><p>This example performs a sparse matrix vector multiplication in CSR format using additional meta data to improve performance. </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse CSR matrix. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> number of columns of the sparse CSR matrix. </p></li>
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of the sparse CSR matrix. </p></li>
<li><p><strong>csr_val</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements of the sparse CSR matrix. </p></li>
<li><p><strong>csr_col_ind</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the column indices of the sparse CSR matrix. </p></li>
<li><p><strong>csr_row_ptr</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m+1</span></code> elements that point to the start of every row of the sparse CSR matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> is supported. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_val</span></code>, <code class="docutils literal notranslate"><span class="pre">csr\_row</span></code> \_ptr, <code class="docutils literal notranslate"><span class="pre">csr\_col</span></code> \_ind, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <code class="docutils literal notranslate"><span class="pre">trans</span></code> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dcsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd">
<span id="_CPPv317aoclsparse_dcsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="_CPPv217aoclsparse_dcsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="aoclsparse_dcsrmv__aoclsparse_operation.doubleCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.doubleCP.aoclsparse_intCP.aoclsparse_intCP.aoclsparse_mat_descrC.doubleCP.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a0cb540a03a9d34d4c9a3c611bed19d13"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dcsrmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_col_ind</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_row_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dcsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single and double precision sparse matrix vector multiplication using CSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_csrmv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in CSR storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans = aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans = aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans = aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p><dl class="simple">
<dt><strong>Example</strong></dt><dd><p>This example performs a sparse matrix vector multiplication in CSR format using additional meta data to improve performance. </p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse CSR matrix. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> number of columns of the sparse CSR matrix. </p></li>
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of the sparse CSR matrix. </p></li>
<li><p><strong>csr_val</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements of the sparse CSR matrix. </p></li>
<li><p><strong>csr_col_ind</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the column indices of the sparse CSR matrix. </p></li>
<li><p><strong>csr_row_ptr</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m+1</span></code> elements that point to the start of every row of the sparse CSR matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> is supported. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_val</span></code>, <code class="docutils literal notranslate"><span class="pre">csr\_row</span></code> \_ptr, <code class="docutils literal notranslate"><span class="pre">csr\_col</span></code> \_ind, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <code class="docutils literal notranslate"><span class="pre">trans</span></code> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_sellmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf">
<span id="_CPPv317aoclsparse_sellmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="_CPPv217aoclsparse_sellmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="aoclsparse_sellmv__aoclsparse_operation.floatCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.floatCP.aoclsparse_intCP.aoclsparse_int.aoclsparse_mat_descrC.floatCP.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1ae25e86aa25343891d076c28b93d30861"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sellmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ell_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ell_col_ind</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ell_width</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_sellmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single &amp; Double precision sparse matrix vector multiplication using ELL storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_ellmv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in ELL storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans = aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans = aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans = aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse ELL matrix. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> number of columns of the sparse ELL matrix. </p></li>
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of the sparse ELL matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse ELL matrix. Both, base-zero and base-one input arrays of ELL matrix are supported </p></li>
<li><p><strong>ell_val</strong> – <strong>[in]</strong> array that contains the elements of the sparse ELL matrix. Padded elements should be zero. </p></li>
<li><p><strong>ell_col_ind</strong> – <strong>[in]</strong> array that contains the column indices of the sparse ELL matrix. Padded column indices should be -1. </p></li>
<li><p><strong>ell_width</strong> – <strong>[in]</strong> number of non-zero elements per row of the sparse ELL matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">ell_width</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_val</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dellmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd">
<span id="_CPPv317aoclsparse_dellmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="_CPPv217aoclsparse_dellmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="aoclsparse_dellmv__aoclsparse_operation.doubleCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.doubleCP.aoclsparse_intCP.aoclsparse_int.aoclsparse_mat_descrC.doubleCP.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a1b2cc12db8bd876e0101c07e51bb9577"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dellmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ell_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">ell_col_ind</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ell_width</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dellmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single &amp; Double precision sparse matrix vector multiplication using ELL storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_ellmv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in ELL storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans = aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans = aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans = aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse ELL matrix. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> number of columns of the sparse ELL matrix. </p></li>
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of the sparse ELL matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse ELL matrix. Both, base-zero and base-one input arrays of ELL matrix are supported </p></li>
<li><p><strong>ell_val</strong> – <strong>[in]</strong> array that contains the elements of the sparse ELL matrix. Padded elements should be zero. </p></li>
<li><p><strong>ell_col_ind</strong> – <strong>[in]</strong> array that contains the column indices of the sparse ELL matrix. Padded column indices should be -1. </p></li>
<li><p><strong>ell_width</strong> – <strong>[in]</strong> number of non-zero elements per row of the sparse ELL matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">ell_width</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_val</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_sdiamv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf">
<span id="_CPPv317aoclsparse_sdiamv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="_CPPv217aoclsparse_sdiamv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="aoclsparse_sdiamv__aoclsparse_operation.floatCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.floatCP.aoclsparse_intCP.aoclsparse_int.aoclsparse_mat_descrC.floatCP.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a61cb298fd867f11c4bad9b2258cc0f88"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sdiamv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dia_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dia_offset</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dia_num_diag</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_sdiamv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single &amp; Double precision sparse matrix vector multiplication using DIA storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_diamv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in DIA storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse DIA matrix. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> number of columns of the sparse DIA matrix. </p></li>
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of the sparse DIA matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse DIA matrix. </p></li>
<li><p><strong>dia_val</strong> – <strong>[in]</strong> array that contains the elements of the sparse DIA matrix. Padded elements should be zero. </p></li>
<li><p><strong>dia_offset</strong> – <strong>[in]</strong> array that contains the offsets of each diagonal of the sparse DIAL matrix.</p></li>
<li><p><strong>dia_num_diag</strong> – <strong>[in]</strong> number of diagonals in the sparse DIA matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">ell_width</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_val</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_ddiamv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd">
<span id="_CPPv317aoclsparse_ddiamv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="_CPPv217aoclsparse_ddiamv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="aoclsparse_ddiamv__aoclsparse_operation.doubleCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.doubleCP.aoclsparse_intCP.aoclsparse_int.aoclsparse_mat_descrC.doubleCP.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1abc870a0715c7d4d0d9ab1ba53dcb3067"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ddiamv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nnz</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dia_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dia_offset</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dia_num_diag</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_ddiamv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_int14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single &amp; Double precision sparse matrix vector multiplication using DIA storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_diamv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in DIA storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse DIA matrix. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> number of columns of the sparse DIA matrix. </p></li>
<li><p><strong>nnz</strong> – <strong>[in]</strong> number of non-zero entries of the sparse DIA matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse DIA matrix. </p></li>
<li><p><strong>dia_val</strong> – <strong>[in]</strong> array that contains the elements of the sparse DIA matrix. Padded elements should be zero. </p></li>
<li><p><strong>dia_offset</strong> – <strong>[in]</strong> array that contains the offsets of each diagonal of the sparse DIAL matrix.</p></li>
<li><p><strong>dia_num_diag</strong> – <strong>[in]</strong> number of diagonals in the sparse DIA matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">ell_width</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_val</span></code>, <code class="docutils literal notranslate"><span class="pre">ell_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_sbsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf">
<span id="_CPPv317aoclsparse_sbsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="_CPPv217aoclsparse_sbsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf"></span><span id="aoclsparse_sbsrmv__aoclsparse_operation.floatCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.floatCP.aoclsparse_intCP.aoclsparse_intCP.aoclsparse_mat_descrC.floatCP.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1ac71674136e803a759a83c9b6efe11fda"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sbsrmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">mb</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nb</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bsr_dim</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bsr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bsr_col_ind</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bsr_row_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_sbsrmv20aoclsparse_operationPKf14aoclsparse_int14aoclsparse_int14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single &amp; Double precision Sparse matrix vector multiplication using BSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_bsrmv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\((mb \cdot \text{bsr\_dim}) \times (nb \cdot \text{bsr\_dim})\)</span> matrix, defined in BSR storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans = aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans = aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans = aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>mb</strong> – <strong>[in]</strong> number of block rows of the sparse BSR matrix. </p></li>
<li><p><strong>nb</strong> – <strong>[in]</strong> number of block columns of the sparse BSR matrix. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse BSR matrix. Both, base-zero and base-one input arrays of BSR matrix are supported </p></li>
<li><p><strong>bsr_val</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnzb</span></code> blocks of the sparse BSR matrix. </p></li>
<li><p><strong>bsr_row_ptr</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">mb+1</span></code> elements that point to the start of every block row of the sparse BSR matrix. </p></li>
<li><p><strong>bsr_col_ind</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> containing the block column indices of the sparse BSR matrix. </p></li>
<li><p><strong>bsr_dim</strong> – <strong>[in]</strong> block dimension of the sparse BSR matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">mb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">mb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">nb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_handle</strong> – the library context was not initialized. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">mb</span></code>, <code class="docutils literal notranslate"><span class="pre">nb</span></code>, <code class="docutils literal notranslate"><span class="pre">nnzb</span></code> or <code class="docutils literal notranslate"><span class="pre">bsr_dim</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">bsr_val</span></code>, <code class="docutils literal notranslate"><span class="pre">bsr_row_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">bsr_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_arch_mismatch</strong> – the device is not supported. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dbsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd">
<span id="_CPPv317aoclsparse_dbsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="_CPPv217aoclsparse_dbsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd"></span><span id="aoclsparse_dbsrmv__aoclsparse_operation.doubleCP.aoclsparse_int.aoclsparse_int.aoclsparse_int.doubleCP.aoclsparse_intCP.aoclsparse_intCP.aoclsparse_mat_descrC.doubleCP.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a80dc6249e2023c9662b232eb4d6b8d6f"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dbsrmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">mb</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">nb</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">bsr_dim</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bsr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bsr_col_ind</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bsr_row_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dbsrmv20aoclsparse_operationPKd14aoclsparse_int14aoclsparse_int14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Single &amp; Double precision Sparse matrix vector multiplication using BSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_bsrmv</span></code> multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\((mb \cdot \text{bsr\_dim}) \times (nb \cdot \text{bsr\_dim})\)</span> matrix, defined in BSR storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans = aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans = aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans = aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>mb</strong> – <strong>[in]</strong> number of block rows of the sparse BSR matrix. </p></li>
<li><p><strong>nb</strong> – <strong>[in]</strong> number of block columns of the sparse BSR matrix. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse BSR matrix. Both, base-zero and base-one input arrays of BSR matrix are supported </p></li>
<li><p><strong>bsr_val</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnzb</span></code> blocks of the sparse BSR matrix. </p></li>
<li><p><strong>bsr_row_ptr</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">mb+1</span></code> elements that point to the start of every block row of the sparse BSR matrix. </p></li>
<li><p><strong>bsr_col_ind</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> containing the block column indices of the sparse BSR matrix. </p></li>
<li><p><strong>bsr_dim</strong> – <strong>[in]</strong> block dimension of the sparse BSR matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">mb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of <code class="docutils literal notranslate"><span class="pre">mb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">nb*bsr_dim</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_handle</strong> – the library context was not initialized. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">mb</span></code>, <code class="docutils literal notranslate"><span class="pre">nb</span></code>, <code class="docutils literal notranslate"><span class="pre">nnzb</span></code> or <code class="docutils literal notranslate"><span class="pre">bsr_dim</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">bsr_val</span></code>, <code class="docutils literal notranslate"><span class="pre">bsr_row_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">bsr_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_arch_mismatch</strong> – the device is not supported. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414aoclsparse_smv20aoclsparse_operationPKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPKfPf">
<span id="_CPPv314aoclsparse_smv20aoclsparse_operationPKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPKfPf"></span><span id="_CPPv214aoclsparse_smv20aoclsparse_operationPKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPKfPf"></span><span id="aoclsparse_smv__aoclsparse_operation.floatCP.aoclsparse_matrix.aoclsparse_mat_descrC.floatCP.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a1c96c16a26b63b2373cca29e9f9300c4"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_smv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414aoclsparse_smv20aoclsparse_operationPKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Computes sparse matrix vector multiplication for real/complex single and double data precisions. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)mv performs a sparse matrix vector multiplication such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 where, x and y are dense vectors, alpha and beta are scalars, and A is a sparse matrix structure. The matrix operation ‘op’ is defined as: <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> Matrix operation. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> The sparse matrix structure containing a sparse matrix of dimension ( <span class="math notranslate nohighlight">\( m \cdot n \)</span>) that is created using aoclsparse_create_?csr. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> Descriptor of the sparse matrix can be one of the following: <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a>, and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>. Both base-zero and base-one are supported, however, the index base needs to match the one used at when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> An array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> An array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, internal structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> has an invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – The requested functionality is not implemented. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414aoclsparse_dmv20aoclsparse_operationPKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPKdPd">
<span id="_CPPv314aoclsparse_dmv20aoclsparse_operationPKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPKdPd"></span><span id="_CPPv214aoclsparse_dmv20aoclsparse_operationPKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPKdPd"></span><span id="aoclsparse_dmv__aoclsparse_operation.doubleCP.aoclsparse_matrix.aoclsparse_mat_descrC.doubleCP.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a723f777a2679682630bac4fa11c4249c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414aoclsparse_dmv20aoclsparse_operationPKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Computes sparse matrix vector multiplication for real/complex single and double data precisions. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)mv performs a sparse matrix vector multiplication such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 where, x and y are dense vectors, alpha and beta are scalars, and A is a sparse matrix structure. The matrix operation ‘op’ is defined as: <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> Matrix operation. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> The sparse matrix structure containing a sparse matrix of dimension ( <span class="math notranslate nohighlight">\( m \cdot n \)</span>) that is created using aoclsparse_create_?csr. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> Descriptor of the sparse matrix can be one of the following: <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a>, and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>. Both base-zero and base-one are supported, however, the index base needs to match the one used at when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> An array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> An array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, internal structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> has an invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – The requested functionality is not implemented. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414aoclsparse_cmv20aoclsparse_operationPK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexPK24aoclsparse_float_complexP24aoclsparse_float_complex">
<span id="_CPPv314aoclsparse_cmv20aoclsparse_operationPK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexPK24aoclsparse_float_complexP24aoclsparse_float_complex"></span><span id="_CPPv214aoclsparse_cmv20aoclsparse_operationPK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexPK24aoclsparse_float_complexP24aoclsparse_float_complex"></span><span id="aoclsparse_cmv__aoclsparse_operation.aoclsparse_float_complexCP.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_float_complexCP.aoclsparse_float_complexCP.aoclsparse_float_complexP"></span><span class="target" id="aoclsparse__functions_8h_1a95c530c0147a7b5b74efbe10c5e08368"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414aoclsparse_cmv20aoclsparse_operationPK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexPK24aoclsparse_float_complexP24aoclsparse_float_complex" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Computes sparse matrix vector multiplication for real/complex single and double data precisions. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)mv performs a sparse matrix vector multiplication such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 where, x and y are dense vectors, alpha and beta are scalars, and A is a sparse matrix structure. The matrix operation ‘op’ is defined as: <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> Matrix operation. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> The sparse matrix structure containing a sparse matrix of dimension ( <span class="math notranslate nohighlight">\( m \cdot n \)</span>) that is created using aoclsparse_create_?csr. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> Descriptor of the sparse matrix can be one of the following: <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a>, and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>. Both base-zero and base-one are supported, however, the index base needs to match the one used at when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> An array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> An array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, internal structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> has an invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – The requested functionality is not implemented. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv414aoclsparse_zmv20aoclsparse_operationPK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexPK25aoclsparse_double_complexP25aoclsparse_double_complex">
<span id="_CPPv314aoclsparse_zmv20aoclsparse_operationPK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexPK25aoclsparse_double_complexP25aoclsparse_double_complex"></span><span id="_CPPv214aoclsparse_zmv20aoclsparse_operationPK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexPK25aoclsparse_double_complexP25aoclsparse_double_complex"></span><span id="aoclsparse_zmv__aoclsparse_operation.aoclsparse_double_complexCP.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_double_complexCP.aoclsparse_double_complexCP.aoclsparse_double_complexP"></span><span class="target" id="aoclsparse__functions_8h_1a6408fcaa64861707cc983b4c94e097c0"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zmv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv414aoclsparse_zmv20aoclsparse_operationPK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexPK25aoclsparse_double_complexP25aoclsparse_double_complex" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Computes sparse matrix vector multiplication for real/complex single and double data precisions. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)mv performs a sparse matrix vector multiplication such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 where, x and y are dense vectors, alpha and beta are scalars, and A is a sparse matrix structure. The matrix operation ‘op’ is defined as: <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> Matrix operation. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> The sparse matrix structure containing a sparse matrix of dimension ( <span class="math notranslate nohighlight">\( m \cdot n \)</span>) that is created using aoclsparse_create_?csr. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> Descriptor of the sparse matrix can be one of the following: <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a>, and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>. Both base-zero and base-one are supported, however, the index base needs to match the one used at when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> An array of <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> An array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <code class="docutils literal notranslate"><span class="pre">n</span></code> elements ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, internal structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">beta</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> has an invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – The requested functionality is not implemented. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_scsrsv20aoclsparse_operationPKf14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPf">
<span id="_CPPv317aoclsparse_scsrsv20aoclsparse_operationPKf14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPf"></span><span id="_CPPv217aoclsparse_scsrsv20aoclsparse_operationPKf14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPf"></span><span id="aoclsparse_scsrsv__aoclsparse_operation.floatCP.aoclsparse_int.floatCP.aoclsparse_intCP.aoclsparse_intCP.aoclsparse_mat_descrC.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1adc194ccc3b81a2adf376bbcec8c2cd2c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_scsrsv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_col_ind</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_row_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_scsrsv20aoclsparse_operationPKf14aoclsparse_intPKfPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solve using CSR storage format for single and double data precisions. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>?srsv solves a sparse triangular linear system of a sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix, defined in CSR storage format, a dense solution vector <span class="math notranslate nohighlight">\(y\)</span> and the right-hand side <span class="math notranslate nohighlight">\(x\)</span> that is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>, such that <div class="math notranslate nohighlight">
\[ op(A) \cdot y = \alpha \cdot x, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix has to be sparse upper or lower triangular matrix with unit or non-unit main diagonal. Matrix has to be sorted. No diagonal element can be omitted from a sparse storage if the solver is called with the non-unit indicator.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse CSR matrix. </p></li>
<li><p><strong>csr_val</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements of the sparse CSR matrix. </p></li>
<li><p><strong>csr_row_ptr</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m+1</span></code> elements that point to the start of every row of the sparse CSR matrix. </p></li>
<li><p><strong>csr_col_ind</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the column indices of the sparse CSR matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, holding the right-hand side. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, holding the solution.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_val</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_row_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a> or <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dcsrsv20aoclsparse_operationPKd14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPd">
<span id="_CPPv317aoclsparse_dcsrsv20aoclsparse_operationPKd14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPd"></span><span id="_CPPv217aoclsparse_dcsrsv20aoclsparse_operationPKd14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPd"></span><span id="aoclsparse_dcsrsv__aoclsparse_operation.doubleCP.aoclsparse_int.doubleCP.aoclsparse_intCP.aoclsparse_intCP.aoclsparse_mat_descrC.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a8bc81bdc251438653d1dc6a78439c64d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dcsrsv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_col_ind</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csr_row_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dcsrsv20aoclsparse_operationPKd14aoclsparse_intPKdPK14aoclsparse_intPK14aoclsparse_intK20aoclsparse_mat_descrPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solve using CSR storage format for single and double data precisions. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>?srsv solves a sparse triangular linear system of a sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix, defined in CSR storage format, a dense solution vector <span class="math notranslate nohighlight">\(y\)</span> and the right-hand side <span class="math notranslate nohighlight">\(x\)</span> that is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>, such that <div class="math notranslate nohighlight">
\[ op(A) \cdot y = \alpha \cdot x, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, only <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> is supported.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix has to be sparse upper or lower triangular matrix with unit or non-unit main diagonal. Matrix has to be sorted. No diagonal element can be omitted from a sparse storage if the solver is called with the non-unit indicator.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>m</strong> – <strong>[in]</strong> number of rows of the sparse CSR matrix. </p></li>
<li><p><strong>csr_val</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements of the sparse CSR matrix. </p></li>
<li><p><strong>csr_row_ptr</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m+1</span></code> elements that point to the start of every row of the sparse CSR matrix. </p></li>
<li><p><strong>csr_col_ind</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the column indices of the sparse CSR matrix. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, holding the right-hand side. </p></li>
<li><p><strong>y</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, holding the solution.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_val</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_row_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">csr_col_ind</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code> or <code class="docutils literal notranslate"><span class="pre">y</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a> or <code class="docutils literal notranslate"><span class="pre">trans</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_strsv20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPf">
<span id="_CPPv316aoclsparse_strsv20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPf"></span><span id="_CPPv216aoclsparse_strsv20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPf"></span><span id="aoclsparse_strsv__aoclsparse_operation.floatC.aoclsparse_matrix.aoclsparse_mat_descrC.floatCP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a158668fc64bd7a9a1a12bffddd7b56ce"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_strsv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_strsv20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_dtrsv20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPd">
<span id="_CPPv316aoclsparse_dtrsv20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPd"></span><span id="_CPPv216aoclsparse_dtrsv20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPd"></span><span id="aoclsparse_dtrsv__aoclsparse_operation.doubleC.aoclsparse_matrix.aoclsparse_mat_descrC.doubleCP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a69ab2256ddf7e9392a4532fe8ac84f24"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dtrsv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_dtrsv20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_ctrsv20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complex">
<span id="_CPPv316aoclsparse_ctrsv20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complex"></span><span id="_CPPv216aoclsparse_ctrsv20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complex"></span><span id="aoclsparse_ctrsv__aoclsparse_operation.aoclsparse_float_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_float_complexCP.aoclsparse_float_complexP"></span><span class="target" id="aoclsparse__functions_8h_1a81fbb136fc6a6ac06ccd9a0846788845"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ctrsv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_ctrsv20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complex" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_ztrsv20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complex">
<span id="_CPPv316aoclsparse_ztrsv20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complex"></span><span id="_CPPv216aoclsparse_ztrsv20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complex"></span><span id="aoclsparse_ztrsv__aoclsparse_operation.aoclsparse_double_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_double_complexCP.aoclsparse_double_complexP"></span><span class="target" id="aoclsparse__functions_8h_1ac95ca70524df5e5d8c953e9d476c7953"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ztrsv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_ztrsv20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complex" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_strsv_kid20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPfK14aoclsparse_int">
<span id="_CPPv320aoclsparse_strsv_kid20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPfK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_strsv_kid20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPfK14aoclsparse_int"></span><span id="aoclsparse_strsv_kid__aoclsparse_operation.floatC.aoclsparse_matrix.aoclsparse_mat_descrC.floatCP.floatP.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1aed8be09edcc6ff647a0c1e26bcd3e37d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_strsv_kid</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_strsv_kid20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfPfK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_dtrsv_kid20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPdK14aoclsparse_int">
<span id="_CPPv320aoclsparse_dtrsv_kid20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPdK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_dtrsv_kid20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPdK14aoclsparse_int"></span><span id="aoclsparse_dtrsv_kid__aoclsparse_operation.doubleC.aoclsparse_matrix.aoclsparse_mat_descrC.doubleCP.doubleP.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1ab9c531f2999d2bca5116622061aa4296"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dtrsv_kid</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_dtrsv_kid20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdPdK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_ctrsv_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complexK14aoclsparse_int">
<span id="_CPPv320aoclsparse_ctrsv_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complexK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_ctrsv_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complexK14aoclsparse_int"></span><span id="aoclsparse_ctrsv_kid__aoclsparse_operation.aoclsparse_float_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_float_complexCP.aoclsparse_float_complexP.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1a1c3268ad7e90d30ad8c97cf95a5ef475"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ctrsv_kid</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_ctrsv_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexP24aoclsparse_float_complexK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_ztrsv_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complexK14aoclsparse_int">
<span id="_CPPv320aoclsparse_ztrsv_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complexK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_ztrsv_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complexK14aoclsparse_int"></span><span id="aoclsparse_ztrsv_kid__aoclsparse_operation.aoclsparse_double_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_double_complexCP.aoclsparse_double_complexP.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1aaa2ac5c7132a0a176acc6a7ba4610ff9"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ztrsv_kid</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_ztrsv_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexP25aoclsparse_double_complexK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse triangular solver for real/complex single and double data precisions. </p>
<p>The functions <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsv+\)</span> solve sparse lower (or upper) triangular linear system of equations. The system is defined by the sparse <span class="math notranslate nohighlight">\(m \times m\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, the dense solution <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(x\)</span>, and the right-hand side dense <span class="math notranslate nohighlight">\(m\)</span>-vector <span class="math notranslate nohighlight">\(b\)</span>. Vector <span class="math notranslate nohighlight">\(b\)</span> is multiplied by <span class="math notranslate nohighlight">\(\alpha\)</span>. The solution <span class="math notranslate nohighlight">\(x\)</span> is estimated by solving <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \quad \text{ or } \quad op(U) \cdot x = \alpha \cdot b, \]</div>
 where <span class="math notranslate nohighlight">\(L = \text{tril}(A)\)</span> is the lower triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>, similarly, <span class="math notranslate nohighlight">\(U = \text{triu}(A)\)</span> is the upper triangle of matrix <span class="math notranslate nohighlight">\(A\)</span>. The operator <span class="math notranslate nohighlight">\(op()\)</span> is regarded as the matrix linear operation, <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none } \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose }\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose }\\ \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine supports only sparse matrices in CSR format.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded has having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are all considered to be unitary.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The input matrix need not be (upper or lower) triangular matrix, in the <code class="docutils literal notranslate"><span class="pre">descr</span></code>, the <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> entity specifies which triangle to consider, namely, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032aca19754b90a64534c0e57736b0c0583812"><span class="std std-ref">aoclsparse_fill_mode_lower</span></a>, then <div class="math notranslate nohighlight">
\[ op(L) \cdot x = \alpha \cdot b, \]</div>
 otherwise, if <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> = <a class="reference internal" href="types.html#aoclsparse__types_8h_1acb87277ab1ffb3c0020a97cb9a5032acab4c33be424075e8ddb3fd1187a733897"><span class="std std-ref">aoclsparse_fill_mode_upper</span></a>, then <div class="math notranslate nohighlight">
\[ op(U) \cdot x = \alpha \cdot b \]</div>
 is solved.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To increase performance and if the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be used more than once to solve for different right-hand sides <span class="math notranslate nohighlight">\(b\)</span>’s, then it is encouraged to provide hints using <code class="docutils literal notranslate"><span class="pre">aoclsparse_set_sv_hint</span></code> and <code class="docutils literal notranslate"><span class="pre">aoclsparse_optimize</span></code>, otherwise, the optimization for the matrix will be done by the solver on entry.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a `_kid` (Kernel ID) variation of TRSV, namely with a suffix of `_kid`, this solver allows to choose which TRSV kernel to use (if possible). Currently the possible choices are: `kid=0` Reference implementation (No explicit AVX instructions). `kid=1` Reference AVX 256-bit implementation only for double data precision and for operations <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>. `kid=2` Kernel Template version using AVX/AVX2 extensions. `kid=3` Kernel Template version using AVX512F+ CPU extensions. Any other Kernel ID value will default to `kid=0`.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation type, either <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a>. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>, used to premultiply right-hand side vector <span class="math notranslate nohighlight">\(b\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[inout]</strong> matrix data. <code class="docutils literal notranslate"><span class="pre">A</span></code> is modified only if solver requires to optimize matrix data. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> matrix descriptor. Supported matrix types are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea736d43c3e394d7c8159a2ff92a4a00c5"><span class="std std-ref">aoclsparse_matrix_type_triangular</span></a>. </p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the right-hand side. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements, storing the solution if solver returns <a class="reference internal" href="types.html#aoclsparse__types_8h_1abff45be4db4b664ef0131233febc394aa8ede90c8e7cc362101eb2fe45d8e815b"><span class="std std-ref">aoclsparse_status_success</span></a>. </p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> Kernel ID, hints a request on which TRSV kernel to use.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully and <span class="math notranslate nohighlight">\(x\)</span> contains the solution to the linear system of equations. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – matrix <span class="math notranslate nohighlight">\(A\)</span> or <span class="math notranslate nohighlight">\(op(A)\)</span> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – One or more of <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> are invalid pointers. </p></li>
<li><p><strong>aoclsparse_status_internal_error</strong> – an internal error occurred. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – the requested operation is not yet implemented. </p></li>
<li><p><strong>other</strong> – possible failure values from a call to <a class="reference internal" href="analysis.html#aoclsparse__analysis_8h_1a5ac60c459514f1f76f8f1acc2c1d2d1f"><span class="std std-ref">aoclsparse_optimize</span></a>. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_sdotmvK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfKfPfPf">
<span id="_CPPv317aoclsparse_sdotmvK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfKfPfPf"></span><span id="_CPPv217aoclsparse_sdotmvK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfKfPfPf"></span><span id="aoclsparse_sdotmv__aoclsparse_operationC.floatC.aoclsparse_matrix.aoclsparse_mat_descrC.floatCP.floatC.floatP.floatP"></span><span class="target" id="aoclsparse__functions_8h_1a9379df2f497c8aa02933dba86dab1aee"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sdotmv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_sdotmvK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descrPKfKfPfPf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Performs sparse matrix-vector multiplication followed by vector-vector multiplication. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>?dotmv multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in a sparse storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p>followed by dot product of dense vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <div class="math notranslate nohighlight">
\[\begin{split} \text{d} = \left\{ \begin{array}{ll} \sum_{i=0}^{min(m,n)-1} x_{i} * y_{i}, &amp; \text{real case} \\ \sum_{i=0}^{min(m,n)-1} \text{conj}(x_i) * y_{i}, &amp; \text{complex case} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, Hermitian matrix is not supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> the sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix structure that is created using <code class="docutils literal notranslate"><span class="pre">aoclsparse_create_(s/d/c/z)csr</span></code></p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. Both base-zero and base-one are supported, however, the index base needs to match the one used when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>d</strong> – <strong>[out]</strong> dot product of y and x</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a49b889919fef58076b89fe888e33493f"><span class="std std-ref">aoclsparse_index_base_zero</span></a>) or, (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a330b34e6026ed02f773ba0a35421962f"><span class="std std-ref">aoclsparse_index_base_one</span></a>) or, matrix base and descr base value do not match. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">internal</span></code> structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">d</span></code> are invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_wrong_type</strong> – matrix data type is not supported. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> == <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>) or, ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1a33c47c96a41e3e80d15c98722026de4b"><span class="std std-ref">aoclsparse_matrix_format_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1af64dc8d4545cdaed7f1734d2f1149927a49c251177ea18d708217dee9e2f525e8"><span class="std std-ref">aoclsparse_csr_mat</span></a>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_ddotmvK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdKdPdPd">
<span id="_CPPv317aoclsparse_ddotmvK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdKdPdPd"></span><span id="_CPPv217aoclsparse_ddotmvK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdKdPdPd"></span><span id="aoclsparse_ddotmv__aoclsparse_operationC.doubleC.aoclsparse_matrix.aoclsparse_mat_descrC.doubleCP.doubleC.doubleP.doubleP"></span><span class="target" id="aoclsparse__functions_8h_1a8dd693e666a13437a183066515732c7d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ddotmv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_ddotmvK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descrPKdKdPdPd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Performs sparse matrix-vector multiplication followed by vector-vector multiplication. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>?dotmv multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in a sparse storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p>followed by dot product of dense vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <div class="math notranslate nohighlight">
\[\begin{split} \text{d} = \left\{ \begin{array}{ll} \sum_{i=0}^{min(m,n)-1} x_{i} * y_{i}, &amp; \text{real case} \\ \sum_{i=0}^{min(m,n)-1} \text{conj}(x_i) * y_{i}, &amp; \text{complex case} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, Hermitian matrix is not supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> the sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix structure that is created using <code class="docutils literal notranslate"><span class="pre">aoclsparse_create_(s/d/c/z)csr</span></code></p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. Both base-zero and base-one are supported, however, the index base needs to match the one used when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>d</strong> – <strong>[out]</strong> dot product of y and x</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a49b889919fef58076b89fe888e33493f"><span class="std std-ref">aoclsparse_index_base_zero</span></a>) or, (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a330b34e6026ed02f773ba0a35421962f"><span class="std std-ref">aoclsparse_index_base_one</span></a>) or, matrix base and descr base value do not match. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">internal</span></code> structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">d</span></code> are invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_wrong_type</strong> – matrix data type is not supported. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> == <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>) or, ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1a33c47c96a41e3e80d15c98722026de4b"><span class="std std-ref">aoclsparse_matrix_format_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1af64dc8d4545cdaed7f1734d2f1149927a49c251177ea18d708217dee9e2f525e8"><span class="std std-ref">aoclsparse_csr_mat</span></a>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_cdotmvK20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexK24aoclsparse_float_complexP24aoclsparse_float_complexP24aoclsparse_float_complex">
<span id="_CPPv317aoclsparse_cdotmvK20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexK24aoclsparse_float_complexP24aoclsparse_float_complexP24aoclsparse_float_complex"></span><span id="_CPPv217aoclsparse_cdotmvK20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexK24aoclsparse_float_complexP24aoclsparse_float_complexP24aoclsparse_float_complex"></span><span id="aoclsparse_cdotmv__aoclsparse_operationC.aoclsparse_float_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_float_complexCP.aoclsparse_float_complexC.aoclsparse_float_complexP.aoclsparse_float_complexP"></span><span class="target" id="aoclsparse__functions_8h_1a7daa95a4bdc2fab6a74b5638084ac51c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cdotmv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_cdotmvK20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK24aoclsparse_float_complexK24aoclsparse_float_complexP24aoclsparse_float_complexP24aoclsparse_float_complex" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Performs sparse matrix-vector multiplication followed by vector-vector multiplication. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>?dotmv multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in a sparse storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p>followed by dot product of dense vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <div class="math notranslate nohighlight">
\[\begin{split} \text{d} = \left\{ \begin{array}{ll} \sum_{i=0}^{min(m,n)-1} x_{i} * y_{i}, &amp; \text{real case} \\ \sum_{i=0}^{min(m,n)-1} \text{conj}(x_i) * y_{i}, &amp; \text{complex case} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, Hermitian matrix is not supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> the sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix structure that is created using <code class="docutils literal notranslate"><span class="pre">aoclsparse_create_(s/d/c/z)csr</span></code></p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. Both base-zero and base-one are supported, however, the index base needs to match the one used when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>d</strong> – <strong>[out]</strong> dot product of y and x</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a49b889919fef58076b89fe888e33493f"><span class="std std-ref">aoclsparse_index_base_zero</span></a>) or, (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a330b34e6026ed02f773ba0a35421962f"><span class="std std-ref">aoclsparse_index_base_one</span></a>) or, matrix base and descr base value do not match. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">internal</span></code> structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">d</span></code> are invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_wrong_type</strong> – matrix data type is not supported. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> == <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>) or, ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1a33c47c96a41e3e80d15c98722026de4b"><span class="std std-ref">aoclsparse_matrix_format_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1af64dc8d4545cdaed7f1734d2f1149927a49c251177ea18d708217dee9e2f525e8"><span class="std std-ref">aoclsparse_csr_mat</span></a>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zdotmvK20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexK25aoclsparse_double_complexP25aoclsparse_double_complexP25aoclsparse_double_complex">
<span id="_CPPv317aoclsparse_zdotmvK20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexK25aoclsparse_double_complexP25aoclsparse_double_complexP25aoclsparse_double_complex"></span><span id="_CPPv217aoclsparse_zdotmvK20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexK25aoclsparse_double_complexP25aoclsparse_double_complexP25aoclsparse_double_complex"></span><span id="aoclsparse_zdotmv__aoclsparse_operationC.aoclsparse_double_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_double_complexCP.aoclsparse_double_complexC.aoclsparse_double_complexP.aoclsparse_double_complexP"></span><span class="target" id="aoclsparse__functions_8h_1a367d1ca4ce9ddfc8aeec7bd8dc0c8353"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zdotmv</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">y</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zdotmvK20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descrPK25aoclsparse_double_complexK25aoclsparse_double_complexP25aoclsparse_double_complexP25aoclsparse_double_complex" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Performs sparse matrix-vector multiplication followed by vector-vector multiplication. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>?dotmv multiplies the scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix, defined in a sparse storage format, and the dense vector <span class="math notranslate nohighlight">\(x\)</span> and adds the result to the dense vector <span class="math notranslate nohighlight">\(y\)</span> that is multiplied by the scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ y := \alpha \cdot op(A) \cdot x + \beta \cdot y, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p>followed by dot product of dense vectors <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> such that <div class="math notranslate nohighlight">
\[\begin{split} \text{d} = \left\{ \begin{array}{ll} \sum_{i=0}^{min(m,n)-1} x_{i} * y_{i}, &amp; \text{real case} \\ \sum_{i=0}^{min(m,n)-1} \text{conj}(x_i) * y_{i}, &amp; \text{complex case} \end{array} \right. \end{split}\]</div>
</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, Hermitian matrix is not supported.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> the sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix structure that is created using <code class="docutils literal notranslate"><span class="pre">aoclsparse_create_(s/d/c/z)csr</span></code></p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix. Both base-zero and base-one are supported, however, the index base needs to match the one used when aoclsparse_matrix was created. </p></li>
<li><p><strong>x</strong> – <strong>[in]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>beta</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>y</strong> – <strong>[inout]</strong> array of atleast <code class="docutils literal notranslate"><span class="pre">m</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A\)</span> or atleast <code class="docutils literal notranslate"><span class="pre">n</span></code> elements if <span class="math notranslate nohighlight">\(op(A) = A^T or A^H\)</span>. </p></li>
<li><p><strong>d</strong> – <strong>[out]</strong> dot product of y and x</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> or <code class="docutils literal notranslate"><span class="pre">nnz</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a49b889919fef58076b89fe888e33493f"><span class="std std-ref">aoclsparse_index_base_zero</span></a>) or, (base != <a class="reference internal" href="types.html#aoclsparse__types_8h_1a461e5b976562f3e6d184cd2df3863b39a330b34e6026ed02f773ba0a35421962f"><span class="std std-ref">aoclsparse_index_base_one</span></a>) or, matrix base and descr base value do not match. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">internal</span></code> structures related to the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">d</span></code> are invalid pointer. </p></li>
<li><p><strong>aoclsparse_status_wrong_type</strong> – matrix data type is not supported. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> == <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a>) or, ( <a class="reference internal" href="types.html#aoclsparse__types_8h_1a33c47c96a41e3e80d15c98722026de4b"><span class="std std-ref">aoclsparse_matrix_format_type</span></a> != <a class="reference internal" href="types.html#aoclsparse__types_8h_1af64dc8d4545cdaed7f1734d2f1149927a49c251177ea18d708217dee9e2f525e8"><span class="std std-ref">aoclsparse_csr_mat</span></a>) </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="level-3">
<h2>Level 3<a class="headerlink" href="#level-3" title="Permalink to this heading">#</a></h2>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_strsmK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_int">
<span id="_CPPv316aoclsparse_strsmK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_int"></span><span id="_CPPv216aoclsparse_strsmK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_int"></span><span id="aoclsparse_strsm__aoclsparse_operationC.floatC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.floatCP.aoclsparse_int.aoclsparse_int.floatP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a49849ebfd42532df087f72ea5bc70bb1"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_strsm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_strsmK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_dtrsmK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_int">
<span id="_CPPv316aoclsparse_dtrsmK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_int"></span><span id="_CPPv216aoclsparse_dtrsmK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_int"></span><span id="aoclsparse_dtrsm__aoclsparse_operationC.doubleC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.doubleCP.aoclsparse_int.aoclsparse_int.doubleP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a5cef6c7935bcd5c1d6f0a77e8578da7e"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dtrsm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_dtrsmK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_ctrsm20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_int">
<span id="_CPPv316aoclsparse_ctrsm20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_int"></span><span id="_CPPv216aoclsparse_ctrsm20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_int"></span><span id="aoclsparse_ctrsm__aoclsparse_operation.aoclsparse_float_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.aoclsparse_float_complexCP.aoclsparse_int.aoclsparse_int.aoclsparse_float_complexP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1abf6c949fd486f7ea78f4e3d8ead31dbb"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ctrsm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_ctrsm20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416aoclsparse_ztrsm20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_int">
<span id="_CPPv316aoclsparse_ztrsm20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_int"></span><span id="_CPPv216aoclsparse_ztrsm20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_int"></span><span id="aoclsparse_ztrsm__aoclsparse_operation.aoclsparse_double_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.aoclsparse_double_complexCP.aoclsparse_int.aoclsparse_int.aoclsparse_double_complexP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1affce5fc9740d3f8082e6d6e3be96237d"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ztrsm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv416aoclsparse_ztrsm20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_strsm_kidK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_intK14aoclsparse_int">
<span id="_CPPv320aoclsparse_strsm_kidK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_intK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_strsm_kidK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_intK14aoclsparse_int"></span><span id="aoclsparse_strsm_kid__aoclsparse_operationC.floatC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.floatCP.aoclsparse_int.aoclsparse_int.floatP.aoclsparse_int.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1accaed4d012eb4b957be57a9e2ca6faaf"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_strsm_kid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_strsm_kidK20aoclsparse_operationKf17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intPf14aoclsparse_intK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_dtrsm_kidK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_intK14aoclsparse_int">
<span id="_CPPv320aoclsparse_dtrsm_kidK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_intK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_dtrsm_kidK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_intK14aoclsparse_int"></span><span id="aoclsparse_dtrsm_kid__aoclsparse_operationC.doubleC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.doubleCP.aoclsparse_int.aoclsparse_int.doubleP.aoclsparse_int.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1a12fda2b8ae4503b19395e4a8860b96fc"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dtrsm_kid</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_dtrsm_kidK20aoclsparse_operationKd17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intPd14aoclsparse_intK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_ctrsm_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_intK14aoclsparse_int">
<span id="_CPPv320aoclsparse_ctrsm_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_intK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_ctrsm_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_intK14aoclsparse_int"></span><span id="aoclsparse_ctrsm_kid__aoclsparse_operation.aoclsparse_float_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.aoclsparse_float_complexCP.aoclsparse_int.aoclsparse_int.aoclsparse_float_complexP.aoclsparse_int.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1aff6f599e8c048674030b75be23ad2292"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ctrsm_kid</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_ctrsm_kid20aoclsparse_operationK24aoclsparse_float_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intP24aoclsparse_float_complex14aoclsparse_intK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv420aoclsparse_ztrsm_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_intK14aoclsparse_int">
<span id="_CPPv320aoclsparse_ztrsm_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_intK14aoclsparse_int"></span><span id="_CPPv220aoclsparse_ztrsm_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_intK14aoclsparse_int"></span><span id="aoclsparse_ztrsm_kid__aoclsparse_operation.aoclsparse_double_complexC.aoclsparse_matrix.aoclsparse_mat_descrC.aoclsparse_order.aoclsparse_double_complexCP.aoclsparse_int.aoclsparse_int.aoclsparse_double_complexP.aoclsparse_int.aoclsparse_intC"></span><span class="target" id="aoclsparse__functions_8h_1ad83453bfe8c28915516630bfb926a3d0"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ztrsm_kid</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">X</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldx</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">kid</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv420aoclsparse_ztrsm_kid20aoclsparse_operationK25aoclsparse_double_complex17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intP25aoclsparse_double_complex14aoclsparse_intK14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Solve sparse triangular linear system of equations with multiple right hand sides for real/complex single and double data precisions. </p>
<p><span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> solves a sparse triangular linear system of equations with multiple right hand sides, of the form <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha B, \]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a sparse matrix of size <span class="math notranslate nohighlight">\(m\)</span>, <span class="math notranslate nohighlight">\(op()\)</span> is a linear operator, <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are rectangular dense matrices of appropiate size, while <span class="math notranslate nohighlight">\(\alpha\)</span> is a scalar. The sparse matrix <span class="math notranslate nohighlight">\(A\)</span> can be interpreted either as a lower triangular or upper triangular. This is indicated by <code class="docutils literal notranslate"><span class="pre">fill_mode</span></code> from the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> where either upper or lower triangular portion of the matrix is only referenced. The matrix can also be of class symmetric in which case only the selected triangular part is used. Matrix <span class="math notranslate nohighlight">\(A\)</span> must be of full rank, that is, the matrix must be invertible. The linear operator <span class="math notranslate nohighlight">\(op()\)</span> can define the transposition or Hermitian transposition operations. By default, no transposition is performed. The right-hand-side matrix <span class="math notranslate nohighlight">\(B\)</span> and the solution matrix <span class="math notranslate nohighlight">\(X\)</span> are dense and must be of the correct size, that is <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, see <code class="docutils literal notranslate"><span class="pre">ldb</span></code> and <code class="docutils literal notranslate"><span class="pre">ldx</span></code> input parameters for further details.</p>
<p>Explicitly, this kernel solves <div class="math notranslate nohighlight">
\[ op(A)\; X = \alpha \; B\text{, with solution } X = \alpha \; (op(A)^{-1}) \; B, \]</div>
 where <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{ if trans} = \text{aoclsparse\_operation\_none,} \\ A^T, &amp; \text{ if trans} = \text{aoclsparse\_operation\_transpose,}\\ A^H, &amp; \text{ if trans} = \text{aoclsparse\_operation\_conjugate\_transpose.} \end{array} \right. \end{split}\]</div>
 If a linear operator is applied then, the possible problems solved are <div class="math notranslate nohighlight">
\[ A^T \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-T} \; B\text{, and } \; A^H \; X = \alpha \; B\text{, with solution } X = \alpha \; A^{-H} \; B. \]</div>
</p>
<p>
1. If the matrix descriptor <code class="docutils literal notranslate"><span class="pre">descr</span></code> specifies that the matrix <span class="math notranslate nohighlight">\(A\)</span> is to be regarded as having a unitary diagonal, then the main diagonal entries of matrix <span class="math notranslate nohighlight">\(A\)</span> are not accessed and are considered to all be ones.</p>
<p>2. If the matrix <span class="math notranslate nohighlight">\(A\)</span> is described as upper triangular, then only the upper triangular portion of the matrix is referenced. Conversely, if the matrix <span class="math notranslate nohighlight">\(A\)</span> is described lower triangular, then only the lower triangular portion of the matrix is used.</p>
<p>3. This set of APIs allocates work array of size <span class="math notranslate nohighlight">\(m\)</span> for each case where the matrices <span class="math notranslate nohighlight">\(B\)</span> or <span class="math notranslate nohighlight">\(X\)</span> are stored in row-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a>).</p>
<p>4. A subset of kernels are parallel (on parallel builds) and can be expected potential acceleration in the solve. These kernels are available when both dense matrices <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are stored in column-major format (<a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>) and thread count is greater than 1 on a parallel build.</p>
<p>5. There is `_kid` (Kernel ID) variation of TRSM, namely with a suffix of `_kid`, this solver allows to choose which underlying TRSV kernels to use (if possible). Currently, all the existing <span class="math notranslate nohighlight">\(\verb+aoclsparse_?trsm+\)</span> kernels are supported.</p>
<p>6. This routine supports only sparse matrices in CSR format.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans</strong> – <strong>[in]</strong> matrix operation to perform on <span class="math notranslate nohighlight">\(A\)</span>. Possible values are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>, <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a>, and aoclsparse_operation_conjugate\_transpose. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix <span class="math notranslate nohighlight">\(A\)</span> of size <span class="math notranslate nohighlight">\(m\)</span>. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix <span class="math notranslate nohighlight">\(A\)</span>. </p></li>
<li><p><strong>order</strong> – <strong>[in]</strong> storage order of dense matrices <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(X\)</span>. Possible options are <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a> and <a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a>. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> dense matrix, potentially rectangular, of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>n</strong> – <strong>[in]</strong> <span class="math notranslate nohighlight">\(n,\)</span> number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span>. </p></li>
<li><p><strong>ldb</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(B\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(B\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldb</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(B\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(B\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldb</span></code> with <code class="docutils literal notranslate"><span class="pre">ldb</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>X</strong> – <strong>[out]</strong> solution matrix <span class="math notranslate nohighlight">\(X,\)</span> dense and potentially rectangular matrix of size <span class="math notranslate nohighlight">\(m \times n\)</span>. </p></li>
<li><p><strong>ldx</strong> – <strong>[in]</strong> leading dimension of <span class="math notranslate nohighlight">\(X\)</span>. Eventhough the matrix <span class="math notranslate nohighlight">\(X\)</span> is considered of size <span class="math notranslate nohighlight">\(m \times n\)</span>, its memory layout may correspond to a larger matrix (<code class="docutils literal notranslate"><span class="pre">ldx</span></code> by <span class="math notranslate nohighlight">\(N&gt;n\)</span>) in which only the submatrix <span class="math notranslate nohighlight">\(X\)</span> is of interest. In this case, this parameter provides means to access the correct elements of <span class="math notranslate nohighlight">\(X\)</span> within the larger layout. <table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>matrix layout  </p></th>
<th class="head"><p>row count  </p></th>
<th class="head"><p>column count </p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3afbaed071ec71fdd90afb7676bdcc7962"><span class="std std-ref">aoclsparse_order_row</span></a></p></td>
<td><p><span class="math notranslate nohighlight">\(m\)</span></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge n\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="types.html#aoclsparse__types_8h_1a833c18bb67d7ec824a92aae6567655e3ab5909b5243395e225a7452e406ff2aac"><span class="std std-ref">aoclsparse_order_column</span></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">ldx</span></code> with <code class="docutils literal notranslate"><span class="pre">ldx</span></code> <span class="math notranslate nohighlight">\(\ge m\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(n\)</span></p></td>
</tr>
</tbody>
</table>
</p></li>
<li><p><strong>kid</strong> – <strong>[in]</strong> kernel ID, hints a request on which kernel to use (see notes).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – indicates that the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldx</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – informs that either <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">X</span></code> pointer is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – this error occurs when the provided matrix <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea175f161770195c2d07c991970b3f5920"><span class="std std-ref">aoclsparse_matrix_type_hermitian</span></a> or when matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415aoclsparse_sp2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix">
<span id="_CPPv315aoclsparse_sp2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix"></span><span id="_CPPv215aoclsparse_sp2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix"></span><span id="aoclsparse_sp2m__aoclsparse_operation.aoclsparse_mat_descrC.aoclsparse_matrixC.aoclsparse_operation.aoclsparse_mat_descrC.aoclsparse_matrixC.aoclsparse_requestC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1a23386a407d350ee8b1d455e0b864ac20"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sp2m</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">opA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descrA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">opB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descrB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv418aoclsparse_request" title="aoclsparse_request"><span class="n"><span class="pre">aoclsparse_request</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">request</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415aoclsparse_sp2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix Sparse matrix multiplication for real and complex datatypes. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_sp2m</span></code> multiplies two sparse matrices in CSR storage format. The result is stored in a newly allocated sparse matrix in CSR format, such that <div class="math notranslate nohighlight">
\[ C := op(A) \cdot op(B), \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if opA} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if opA} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if opA} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 and <div class="math notranslate nohighlight">
\[\begin{split} op(B) = \left\{ \begin{array}{ll} B, &amp; \text{if opB} = \text{aoclsparse\_operation\_none} \\ B^T, &amp; \text{if opB} = \text{aoclsparse\_operation\_transpose} \\ B^H, &amp; \text{if opB} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(m \times k\)</span> matrix , <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(k \times n\)</span> matrix, resulting in <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span>, for opA and opB = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>. <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(k \times m\)</span> matrix when opA = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a> and <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(n \times k\)</span> matrix when opB = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a></p>
<p>aoclsparse_sp2m can be run in single-stage or two-stage. The single-stage algorithm allocates and computes the entire output matrix in a single stage <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054faa4a3a71465c4332bc47a68e9e861337d"><span class="std std-ref">aoclsparse_stage_full_computation</span></a>. Whereas, in two-stage algorithm, the first stage <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fa256467fdb5d24e4c0561a46b048e4658"><span class="std std-ref">aoclsparse_stage_nnz_count</span></a> allocates memory for the output matrix and computes the number of entries of the matrix. The second stage <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fab770de47d8a31f0c1b6c3ceb68a3b1c3"><span class="std std-ref">aoclsparse_stage_finalize</span></a> computes column indices of non-zero elements and values of the output matrix. The second stage has to be invoked only after the first stage. But, it can be also be invoked multiple times consecutively when the sparsity structure of input matrices remains unchanged, with only the values getting updated.</p>
<p><dl class="simple">
<dt><strong>Example</strong></dt><dd><p>Shows multiplication of 2 sparse matrices to give a newly allocated sparse matrix <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">A</span><span class="p">;</span>
<span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_A</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_A</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">B</span><span class="p">;</span>
<span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_B</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_B</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_row_ptr_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_col_ind_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">double</span><span class="w">             </span><span class="o">*</span><span class="n">csr_val_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="n">C_N</span><span class="p">;</span>
<span class="n">aoclsparse_status</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">aoclsparse_stage_full_computation</span><span class="p">;</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aoclsparse_sp2m</span><span class="p">(</span><span class="n">opA</span><span class="p">,</span>
<span class="w">        </span><span class="n">descrA</span><span class="p">,</span>
<span class="w">        </span><span class="n">A</span><span class="p">,</span>
<span class="w">        </span><span class="n">opB</span><span class="p">,</span>
<span class="w">        </span><span class="n">descrB</span><span class="p">,</span>
<span class="w">        </span><span class="n">B</span><span class="p">,</span>
<span class="w">        </span><span class="n">request</span><span class="p">,</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">C</span><span class="p">);</span>

<span class="n">aoclsparse_export_dcsr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nnz_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_row_ptr_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_col_ind_C</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csr_val_C</span><span class="p">);</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opA</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>descrA</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> . </p></li>
<li><p><strong>opB</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(B\)</span> operation type. </p></li>
<li><p><strong>descrB</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span> . </p></li>
<li><p><strong>request</strong> – <strong>[in]</strong> Specifies full computation or two-stage algorithm <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fa256467fdb5d24e4c0561a46b048e4658"><span class="std std-ref">aoclsparse_stage_nnz_count</span></a> , Only rowIndex array of the CSR matrix is computed internally. The output sparse CSR matrix can be extracted to measure the memory required for full operation. <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fab770de47d8a31f0c1b6c3ceb68a3b1c3"><span class="std std-ref">aoclsparse_stage_finalize</span></a> . Finalize computation of remaining output arrays ( column indices and values of output matrix entries) . Has to be called only after aoclsparse_sp2m call with aoclsparse_stage_nnz_count parameter. <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054faa4a3a71465c4332bc47a68e9e861337d"><span class="std std-ref">aoclsparse_stage_full_computation</span></a> . Perform the entire computation in a single step.</p></li>
<li><p><strong>*C</strong> – <strong>[out]</strong> Pointer to sparse CSR matrix <span class="math notranslate nohighlight">\(C\)</span> . Matrix <span class="math notranslate nohighlight">\(C\)</span> arrays will always have zero-based indexing, irrespective of matrix <span class="math notranslate nohighlight">\(A\)</span> or matrix <span class="math notranslate nohighlight">\(B\)</span> being one-based or zero-based indexing. The column indices of the output matrix in CSR format can appear unsorted.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descrA</span></code>, <code class="docutils literal notranslate"><span class="pre">descrB</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – input size parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – input parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_wrong_type</strong> – A and B matrix datatypes dont match. </p></li>
<li><p><strong>aoclsparse_status_memory_error</strong> – Memory allocation failure. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> is not in CSR format</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415aoclsparse_spmm20aoclsparse_operationK17aoclsparse_matrixK17aoclsparse_matrixP17aoclsparse_matrix">
<span id="_CPPv315aoclsparse_spmm20aoclsparse_operationK17aoclsparse_matrixK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="_CPPv215aoclsparse_spmm20aoclsparse_operationK17aoclsparse_matrixK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="aoclsparse_spmm__aoclsparse_operation.aoclsparse_matrixC.aoclsparse_matrixC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1a2bcc495d7104044329f2c18367b8a67e"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_spmm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">opA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415aoclsparse_spmm20aoclsparse_operationK17aoclsparse_matrixK17aoclsparse_matrixP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix Sparse matrix multiplication for real and complex datatypes. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_spmm</span></code> multiplies two sparse matrices in CSR storage format. The result is stored in a newly allocated sparse matrix in CSR format, such that <div class="math notranslate nohighlight">
\[ C := op(A) \cdot B, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if opA} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if opA} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if opA} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(m \times k\)</span> matrix , <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(k \times n\)</span> matrix, resulting in <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span>, for opA = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a>. <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(k \times m\)</span> matrix when opA = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a88282158467fda2f6a5b7face8b7630a"><span class="std std-ref">aoclsparse_operation_transpose</span></a> or <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2a57de0ca17681a04eae397aefd28692c2"><span class="std std-ref">aoclsparse_operation_conjugate_transpose</span></a></p>
<p><dl class="simple">
<dt><strong>Example</strong></dt><dd><p>Shows multiplication of 2 sparse matrices to give a newly allocated sparse matrix <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">A</span><span class="p">;</span>
<span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_A</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_A</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">B</span><span class="p">;</span>
<span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_B</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_B</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_row_ptr_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_col_ind_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">double</span><span class="w">             </span><span class="o">*</span><span class="n">csr_val_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="n">C_N</span><span class="p">;</span>
<span class="n">aoclsparse_status</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aoclsparse_spmm</span><span class="p">(</span><span class="n">opA</span><span class="p">,</span>
<span class="w">        </span><span class="n">A</span><span class="p">,</span>
<span class="w">        </span><span class="n">B</span><span class="p">,</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">C</span><span class="p">);</span>

<span class="n">aoclsparse_export_dcsr</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nnz_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_row_ptr_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_col_ind_C</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csr_val_C</span><span class="p">);</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>opA</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type.</p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>.</p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span>.</p></li>
<li><p><strong>*C</strong> – <strong>[out]</strong> Pointer to sparse CSR matrix <span class="math notranslate nohighlight">\(C\)</span> . Matrix <span class="math notranslate nohighlight">\(C\)</span> arrays will always have zero-based indexing, irrespective of matrix <span class="math notranslate nohighlight">\(A\)</span> or matrix <span class="math notranslate nohighlight">\(B\)</span> being one-based or zero-based indexing. The column indices of the output matrix in CSR format can appear unsorted.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – input size parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – input parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_wrong_type</strong> – A and B matrix datatypes dont match. </p></li>
<li><p><strong>aoclsparse_status_memory_error</strong> – Memory allocation failure. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – Input matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> or \B is not in CSR format</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_scsrmm20aoclsparse_operationKfK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intKfPf14aoclsparse_int">
<span id="_CPPv317aoclsparse_scsrmm20aoclsparse_operationKfK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intKfPf14aoclsparse_int"></span><span id="_CPPv217aoclsparse_scsrmm20aoclsparse_operationKfK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intKfPf14aoclsparse_int"></span><span id="aoclsparse_scsrmm__aoclsparse_operation.floatC.aoclsparse_matrixC.aoclsparse_mat_descrC.aoclsparse_order.floatCP.aoclsparse_int.aoclsparse_int.floatC.floatP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a763aa4de6338ba2d0a2284620677f3db"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_scsrmm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_scsrmm20aoclsparse_operationKfK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKf14aoclsparse_int14aoclsparse_intKfPf14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix dense matrix multiplication using CSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)csrmm multiplies a scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times k\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, defined in CSR storage format, and a dense <span class="math notranslate nohighlight">\(k \times n\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span> and adds the result to the dense <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span> that is multiplied by a scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ C := \alpha \cdot op(A) \cdot B + \beta \cdot C, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ldc</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">csr_val</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">csr_col_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Op</strong> – <strong>[in]</strong> Matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>Alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> Sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> structure. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. Both, base-zero and base-one input arrays of CSR matrix are supported </p></li>
<li><p><strong>Order</strong> – <strong>[in]</strong> Aoclsparse_order_row/aoclsparse_order_column for dense matrix </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldb \times n\)</span> or <span class="math notranslate nohighlight">\(ldb \times k\)</span> . </p></li>
<li><p><strong>N</strong> – <strong>[in]</strong> Number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>. </p></li>
<li><p><strong>Ldb</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(B\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>Beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>C</strong> – <strong>[inout]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldc \times n\)</span>. </p></li>
<li><p><strong>Ldc</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(C\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldc</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – The pointer <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">C</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – The value of <code class="docutils literal notranslate"><span class="pre">descr-&gt;base</span></code>, <code class="docutils literal notranslate"><span class="pre">A-&gt;base</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dcsrmm20aoclsparse_operationKdK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intKdPd14aoclsparse_int">
<span id="_CPPv317aoclsparse_dcsrmm20aoclsparse_operationKdK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intKdPd14aoclsparse_int"></span><span id="_CPPv217aoclsparse_dcsrmm20aoclsparse_operationKdK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intKdPd14aoclsparse_int"></span><span id="aoclsparse_dcsrmm__aoclsparse_operation.doubleC.aoclsparse_matrixC.aoclsparse_mat_descrC.aoclsparse_order.doubleCP.aoclsparse_int.aoclsparse_int.doubleC.doubleP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a24eeb65cd282a32e7f9e7e4dd51501f5"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dcsrmm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dcsrmm20aoclsparse_operationKdK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPKd14aoclsparse_int14aoclsparse_intKdPd14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix dense matrix multiplication using CSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)csrmm multiplies a scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times k\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, defined in CSR storage format, and a dense <span class="math notranslate nohighlight">\(k \times n\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span> and adds the result to the dense <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span> that is multiplied by a scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ C := \alpha \cdot op(A) \cdot B + \beta \cdot C, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ldc</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">csr_val</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">csr_col_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Op</strong> – <strong>[in]</strong> Matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>Alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> Sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> structure. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. Both, base-zero and base-one input arrays of CSR matrix are supported </p></li>
<li><p><strong>Order</strong> – <strong>[in]</strong> Aoclsparse_order_row/aoclsparse_order_column for dense matrix </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldb \times n\)</span> or <span class="math notranslate nohighlight">\(ldb \times k\)</span> . </p></li>
<li><p><strong>N</strong> – <strong>[in]</strong> Number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>. </p></li>
<li><p><strong>Ldb</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(B\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>Beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>C</strong> – <strong>[inout]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldc \times n\)</span>. </p></li>
<li><p><strong>Ldc</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(C\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldc</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – The pointer <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">C</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – The value of <code class="docutils literal notranslate"><span class="pre">descr-&gt;base</span></code>, <code class="docutils literal notranslate"><span class="pre">A-&gt;base</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_ccsrmm20aoclsparse_operationK24aoclsparse_float_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intK24aoclsparse_float_complexP24aoclsparse_float_complex14aoclsparse_int">
<span id="_CPPv317aoclsparse_ccsrmm20aoclsparse_operationK24aoclsparse_float_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intK24aoclsparse_float_complexP24aoclsparse_float_complex14aoclsparse_int"></span><span id="_CPPv217aoclsparse_ccsrmm20aoclsparse_operationK24aoclsparse_float_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intK24aoclsparse_float_complexP24aoclsparse_float_complex14aoclsparse_int"></span><span id="aoclsparse_ccsrmm__aoclsparse_operation.aoclsparse_float_complexC.aoclsparse_matrixC.aoclsparse_mat_descrC.aoclsparse_order.aoclsparse_float_complexCP.aoclsparse_int.aoclsparse_int.aoclsparse_float_complexC.aoclsparse_float_complexP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1a119e516d83be1361b372a6c72fc739bf"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_ccsrmm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_ccsrmm20aoclsparse_operationK24aoclsparse_float_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK24aoclsparse_float_complex14aoclsparse_int14aoclsparse_intK24aoclsparse_float_complexP24aoclsparse_float_complex14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix dense matrix multiplication using CSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)csrmm multiplies a scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times k\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, defined in CSR storage format, and a dense <span class="math notranslate nohighlight">\(k \times n\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span> and adds the result to the dense <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span> that is multiplied by a scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ C := \alpha \cdot op(A) \cdot B + \beta \cdot C, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ldc</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">csr_val</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">csr_col_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Op</strong> – <strong>[in]</strong> Matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>Alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> Sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> structure. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. Both, base-zero and base-one input arrays of CSR matrix are supported </p></li>
<li><p><strong>Order</strong> – <strong>[in]</strong> Aoclsparse_order_row/aoclsparse_order_column for dense matrix </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldb \times n\)</span> or <span class="math notranslate nohighlight">\(ldb \times k\)</span> . </p></li>
<li><p><strong>N</strong> – <strong>[in]</strong> Number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>. </p></li>
<li><p><strong>Ldb</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(B\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>Beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>C</strong> – <strong>[inout]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldc \times n\)</span>. </p></li>
<li><p><strong>Ldc</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(C\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldc</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – The pointer <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">C</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – The value of <code class="docutils literal notranslate"><span class="pre">descr-&gt;base</span></code>, <code class="docutils literal notranslate"><span class="pre">A-&gt;base</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_zcsrmm20aoclsparse_operationK25aoclsparse_double_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intK25aoclsparse_double_complexP25aoclsparse_double_complex14aoclsparse_int">
<span id="_CPPv317aoclsparse_zcsrmm20aoclsparse_operationK25aoclsparse_double_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intK25aoclsparse_double_complexP25aoclsparse_double_complex14aoclsparse_int"></span><span id="_CPPv217aoclsparse_zcsrmm20aoclsparse_operationK25aoclsparse_double_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intK25aoclsparse_double_complexP25aoclsparse_double_complex14aoclsparse_int"></span><span id="aoclsparse_zcsrmm__aoclsparse_operation.aoclsparse_double_complexC.aoclsparse_matrixC.aoclsparse_mat_descrC.aoclsparse_order.aoclsparse_double_complexCP.aoclsparse_int.aoclsparse_int.aoclsparse_double_complexC.aoclsparse_double_complexP.aoclsparse_int"></span><span class="target" id="aoclsparse__functions_8h_1abbc3fe2d43d977f1ac8ebb5f7c076694"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zcsrmm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <a class="reference internal" href="types.html#_CPPv416aoclsparse_order" title="aoclsparse_order"><span class="n"><span class="pre">aoclsparse_order</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">order</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldb</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">beta</span></span>, <span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span>, <a class="reference internal" href="types.html#_CPPv414aoclsparse_int" title="aoclsparse_int"><span class="n"><span class="pre">aoclsparse_int</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">ldc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_zcsrmm20aoclsparse_operationK25aoclsparse_double_complexK17aoclsparse_matrixK20aoclsparse_mat_descr16aoclsparse_orderPK25aoclsparse_double_complex14aoclsparse_int14aoclsparse_intK25aoclsparse_double_complexP25aoclsparse_double_complex14aoclsparse_int" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix dense matrix multiplication using CSR storage format. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_</span></code>(s/d/c/z)csrmm multiplies a scalar <span class="math notranslate nohighlight">\(\alpha\)</span> with a sparse <span class="math notranslate nohighlight">\(m \times k\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, defined in CSR storage format, and a dense <span class="math notranslate nohighlight">\(k \times n\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span> and adds the result to the dense <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span> that is multiplied by a scalar <span class="math notranslate nohighlight">\(\beta\)</span>, such that <div class="math notranslate nohighlight">
\[ C := \alpha \cdot op(A) \cdot B + \beta \cdot C, \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ldc</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">beta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">csr_row_ptr</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">csr_val</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">csr_col_ind</span><span class="p">[</span><span class="n">k</span><span class="p">]][</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Op</strong> – <strong>[in]</strong> Matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>Alpha</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\alpha\)</span>. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> Sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> structure. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. Both, base-zero and base-one input arrays of CSR matrix are supported </p></li>
<li><p><strong>Order</strong> – <strong>[in]</strong> Aoclsparse_order_row/aoclsparse_order_column for dense matrix </p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldb \times n\)</span> or <span class="math notranslate nohighlight">\(ldb \times k\)</span> . </p></li>
<li><p><strong>N</strong> – <strong>[in]</strong> Number of columns of the dense matrix <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(C\)</span>. </p></li>
<li><p><strong>Ldb</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(B\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>). </p></li>
<li><p><strong>Beta</strong> – <strong>[in]</strong> Scalar <span class="math notranslate nohighlight">\(\beta\)</span>. </p></li>
<li><p><strong>C</strong> – <strong>[inout]</strong> Array of dimension <span class="math notranslate nohighlight">\(ldc \times n\)</span>. </p></li>
<li><p><strong>Ldc</strong> – <strong>[in]</strong> Leading dimension of <span class="math notranslate nohighlight">\(C\)</span>, must be at least <span class="math notranslate nohighlight">\(\max{(1, m)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A\)</span>) or <span class="math notranslate nohighlight">\(\max{(1, k)}\)</span> ( <span class="math notranslate nohighlight">\(op(A) = A^T\)</span> or <span class="math notranslate nohighlight">\(op(A) = A^H\)</span>).</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The value of <code class="docutils literal notranslate"><span class="pre">m</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">nnz</span></code>, <code class="docutils literal notranslate"><span class="pre">ldb</span></code> or <code class="docutils literal notranslate"><span class="pre">ldc</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – The pointer <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, or <code class="docutils literal notranslate"><span class="pre">C</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_invalid_value</strong> – The value of <code class="docutils literal notranslate"><span class="pre">descr-&gt;base</span></code>, <code class="docutils literal notranslate"><span class="pre">A-&gt;base</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_dcsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix">
<span id="_CPPv317aoclsparse_dcsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix"></span><span id="_CPPv217aoclsparse_dcsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix"></span><span id="aoclsparse_dcsr2m__aoclsparse_operation.aoclsparse_mat_descrC.aoclsparse_matrixC.aoclsparse_operation.aoclsparse_mat_descrC.aoclsparse_matrixC.aoclsparse_requestC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1a49e4887bac55a65ed7ecbafcd293436c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dcsr2m</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans_A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descrA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">csrA</span></span>, <a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descrB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">csrB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv418aoclsparse_request" title="aoclsparse_request"><span class="n"><span class="pre">aoclsparse_request</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">request</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csrC</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_dcsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix Sparse matrix multiplication using CSR storage format for single and double precision datatypes. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_csr2m</span></code> multiplies a sparse <span class="math notranslate nohighlight">\(m \times k\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, defined in CSR storage format, and the sparse <span class="math notranslate nohighlight">\(k \times n\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span>, defined in CSR storage format and stores the result to the sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span>, such that <div class="math notranslate nohighlight">
\[ C := op(A) \cdot op(B), \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 and <div class="math notranslate nohighlight">
\[\begin{split} op(B) = \left\{ \begin{array}{ll} B, &amp; \text{if trans\_B} = \text{aoclsparse\_operation\_none} \\ B^T, &amp; \text{if trans\_B} = \text{aoclsparse\_operation\_transpose} \\ B^H, &amp; \text{if trans\_B} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p><dl class="simple">
<dt><strong>Example</strong></dt><dd><p>Shows multiplication of 2 sparse matrices to give a newly allocated sparse matrix <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">csrA</span><span class="p">;</span>
<span class="w">    </span><span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrA</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_A</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_A</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="w">    </span><span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">csrB</span><span class="p">;</span>
<span class="w">    </span><span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrB</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_B</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_B</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">csrC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_row_ptr_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_col_ind_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">double</span><span class="w">             </span><span class="o">*</span><span class="n">csr_val_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="n">C_N</span><span class="p">;</span>
<span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">aoclsparse_stage_nnz_count</span><span class="p">;</span>
<span class="n">CHECK_AOCLSPARSE_ERROR</span><span class="p">(</span><span class="n">aoclsparse_dcsr2m</span><span class="p">(</span><span class="n">transA</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">transB</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">request</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">csrC</span><span class="p">));</span>

<span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">aoclsparse_stage_finalize</span><span class="p">;</span>
<span class="n">CHECK_AOCLSPARSE_ERROR</span><span class="p">(</span><span class="n">aoclsparse_dcsr2m</span><span class="p">(</span><span class="n">transA</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">transB</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">request</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">csrC</span><span class="p">));</span>
<span class="n">aoclsparse_export_mat_csr</span><span class="p">(</span><span class="n">csrC</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nnz_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_row_ptr_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_col_ind_C</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csr_val_C</span><span class="p">);</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans_A</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>descrA</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. </p></li>
<li><p><strong>csrA</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> structure. </p></li>
<li><p><strong>trans_B</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(B\)</span> operation type. </p></li>
<li><p><strong>descrB</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. </p></li>
<li><p><strong>csrB</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span> structure. </p></li>
<li><p><strong>request</strong> – <strong>[in]</strong> Specifies full computation or two-stage algorithm <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fa256467fdb5d24e4c0561a46b048e4658"><span class="std std-ref">aoclsparse_stage_nnz_count</span></a> , Only rowIndex array of the CSR matrix is computed internally. The output sparse CSR matrix can be extracted to measure the memory required for full operation. <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fab770de47d8a31f0c1b6c3ceb68a3b1c3"><span class="std std-ref">aoclsparse_stage_finalize</span></a> . Finalize computation of remaining output arrays ( column indices and values of output matrix entries) . Has to be called only after aoclsparse_dcsr2m call with aoclsparse_stage_nnz_count parameter. <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054faa4a3a71465c4332bc47a68e9e861337d"><span class="std std-ref">aoclsparse_stage_full_computation</span></a> . Perform the entire computation in a single step.</p></li>
<li><p><strong>*csrC</strong> – <strong>[out]</strong> Pointer to sparse CSR matrix <span class="math notranslate nohighlight">\(C\)</span> structure.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – input parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descrA</span></code>, <code class="docutils literal notranslate"><span class="pre">csr</span></code>, <code class="docutils literal notranslate"><span class="pre">descrB</span></code>, <code class="docutils literal notranslate"><span class="pre">csrB</span></code>, <code class="docutils literal notranslate"><span class="pre">csrC</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> is not in CSR format</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417aoclsparse_scsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix">
<span id="_CPPv317aoclsparse_scsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix"></span><span id="_CPPv217aoclsparse_scsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix"></span><span id="aoclsparse_scsr2m__aoclsparse_operation.aoclsparse_mat_descrC.aoclsparse_matrixC.aoclsparse_operation.aoclsparse_mat_descrC.aoclsparse_matrixC.aoclsparse_requestC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1a778b96f08fa35401eab4d134eeb02d6b"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_scsr2m</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans_A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descrA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">csrA</span></span>, <a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">trans_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descrB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">csrB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv418aoclsparse_request" title="aoclsparse_request"><span class="n"><span class="pre">aoclsparse_request</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">request</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">csrC</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv417aoclsparse_scsr2m20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrix20aoclsparse_operationK20aoclsparse_mat_descrK17aoclsparse_matrixK18aoclsparse_requestP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse matrix Sparse matrix multiplication using CSR storage format for single and double precision datatypes. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_csr2m</span></code> multiplies a sparse <span class="math notranslate nohighlight">\(m \times k\)</span> matrix <span class="math notranslate nohighlight">\(A\)</span>, defined in CSR storage format, and the sparse <span class="math notranslate nohighlight">\(k \times n\)</span> matrix <span class="math notranslate nohighlight">\(B\)</span>, defined in CSR storage format and stores the result to the sparse <span class="math notranslate nohighlight">\(m \times n\)</span> matrix <span class="math notranslate nohighlight">\(C\)</span>, such that <div class="math notranslate nohighlight">
\[ C := op(A) \cdot op(B), \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if trans\_A} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 and <div class="math notranslate nohighlight">
\[\begin{split} op(B) = \left\{ \begin{array}{ll} B, &amp; \text{if trans\_B} = \text{aoclsparse\_operation\_none} \\ B^T, &amp; \text{if trans\_B} = \text{aoclsparse\_operation\_transpose} \\ B^H, &amp; \text{if trans\_B} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
</p>
<p><dl class="simple">
<dt><strong>Example</strong></dt><dd><p>Shows multiplication of 2 sparse matrices to give a newly allocated sparse matrix <div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">csrA</span><span class="p">;</span>
<span class="w">    </span><span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrA</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_A</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_A</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_A</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="w">    </span><span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">csrB</span><span class="p">;</span>
<span class="w">    </span><span class="n">aoclsparse_create_dcsr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">csrB</span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">nnz_B</span><span class="p">,</span><span class="w"> </span><span class="n">csr_row_ptr_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_col_ind_B</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">csr_val_B</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

<span class="n">aoclsparse_matrix</span><span class="w">  </span><span class="n">csrC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_row_ptr_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="o">*</span><span class="n">csr_col_ind_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="kt">double</span><span class="w">             </span><span class="o">*</span><span class="n">csr_val_C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="n">aoclsparse_int</span><span class="w"> </span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="n">C_N</span><span class="p">;</span>
<span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">aoclsparse_stage_nnz_count</span><span class="p">;</span>
<span class="n">CHECK_AOCLSPARSE_ERROR</span><span class="p">(</span><span class="n">aoclsparse_dcsr2m</span><span class="p">(</span><span class="n">transA</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">transB</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">request</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">csrC</span><span class="p">));</span>

<span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">aoclsparse_stage_finalize</span><span class="p">;</span>
<span class="n">CHECK_AOCLSPARSE_ERROR</span><span class="p">(</span><span class="n">aoclsparse_dcsr2m</span><span class="p">(</span><span class="n">transA</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrA</span><span class="p">,</span>
<span class="w">    </span><span class="n">transB</span><span class="p">,</span>
<span class="w">    </span><span class="n">descrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">csrB</span><span class="p">,</span>
<span class="w">    </span><span class="n">request</span><span class="p">,</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">csrC</span><span class="p">));</span>
<span class="n">aoclsparse_export_mat_csr</span><span class="p">(</span><span class="n">csrC</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_M</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">C_N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nnz_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_row_ptr_C</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">csr_col_ind_C</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csr_val_C</span><span class="p">);</span>
</pre></div>
</div>
</p>
</dd>
</dl>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>trans_A</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>descrA</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. </p></li>
<li><p><strong>csrA</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(A\)</span> structure. </p></li>
<li><p><strong>trans_B</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(B\)</span> operation type. </p></li>
<li><p><strong>descrB</strong> – <strong>[in]</strong> descriptor of the sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> is supported. </p></li>
<li><p><strong>csrB</strong> – <strong>[in]</strong> sparse CSR matrix <span class="math notranslate nohighlight">\(B\)</span> structure. </p></li>
<li><p><strong>request</strong> – <strong>[in]</strong> Specifies full computation or two-stage algorithm <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fa256467fdb5d24e4c0561a46b048e4658"><span class="std std-ref">aoclsparse_stage_nnz_count</span></a> , Only rowIndex array of the CSR matrix is computed internally. The output sparse CSR matrix can be extracted to measure the memory required for full operation. <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054fab770de47d8a31f0c1b6c3ceb68a3b1c3"><span class="std std-ref">aoclsparse_stage_finalize</span></a> . Finalize computation of remaining output arrays ( column indices and values of output matrix entries) . Has to be called only after aoclsparse_dcsr2m call with aoclsparse_stage_nnz_count parameter. <a class="reference internal" href="types.html#aoclsparse__types_8h_1a9c8bac95afbf160fba0eb1b9ee55054faa4a3a71465c4332bc47a68e9e861337d"><span class="std std-ref">aoclsparse_stage_full_computation</span></a> . Perform the entire computation in a single step.</p></li>
<li><p><strong>*csrC</strong> – <strong>[out]</strong> Pointer to sparse CSR matrix <span class="math notranslate nohighlight">\(C\)</span> structure.</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – input parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descrA</span></code>, <code class="docutils literal notranslate"><span class="pre">csr</span></code>, <code class="docutils literal notranslate"><span class="pre">descrB</span></code>, <code class="docutils literal notranslate"><span class="pre">csrB</span></code>, <code class="docutils literal notranslate"><span class="pre">csrC</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3e9540e704f07c06ac06f679b6c64d2b"><span class="std std-ref">aoclsparse_matrix_type_general</span></a> or input matrices <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> is not in CSR format</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415aoclsparse_saddK20aoclsparse_operationK17aoclsparse_matrixKfK17aoclsparse_matrixP17aoclsparse_matrix">
<span id="_CPPv315aoclsparse_saddK20aoclsparse_operationK17aoclsparse_matrixKfK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="_CPPv215aoclsparse_saddK20aoclsparse_operationK17aoclsparse_matrixKfK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="aoclsparse_sadd__aoclsparse_operationC.aoclsparse_matrixC.floatC.aoclsparse_matrixC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1a544716167926468d49e6f1407f660fa9"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_sadd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415aoclsparse_saddK20aoclsparse_operationK17aoclsparse_matrixKfK17aoclsparse_matrixP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Addition of two sparse matrices. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)add</span></code> sums two sparse matrices and returns the result as a newly allocated sparse matrix for real and complex types, respectively. It performs the following operation: <div class="math notranslate nohighlight">
\[ C = \alpha * op ( A ) + B \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix and <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix if op = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <span class="math notranslate nohighlight">\(n \times m\)</span> otherwise and the result matrix <span class="math notranslate nohighlight">\(C\)</span> has the same dimension as <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only matrices in CSR format are supported in this release.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar with same precision as <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrix </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(B\)</span></p></li>
<li><p><strong>*C</strong> – <strong>[out]</strong> pointer to the sparse output matrix <span class="math notranslate nohighlight">\(C\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> or <code class="docutils literal notranslate"><span class="pre">C</span></code> are invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not compatible. </p></li>
<li><p><strong>aoclsparse_status_memory_error</strong> – Memory allocation failure. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – Matrices are not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415aoclsparse_daddK20aoclsparse_operationK17aoclsparse_matrixKdK17aoclsparse_matrixP17aoclsparse_matrix">
<span id="_CPPv315aoclsparse_daddK20aoclsparse_operationK17aoclsparse_matrixKdK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="_CPPv215aoclsparse_daddK20aoclsparse_operationK17aoclsparse_matrixKdK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="aoclsparse_dadd__aoclsparse_operationC.aoclsparse_matrixC.doubleC.aoclsparse_matrixC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1ad85c413da6799eb0badfe611c8068119"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dadd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415aoclsparse_daddK20aoclsparse_operationK17aoclsparse_matrixKdK17aoclsparse_matrixP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Addition of two sparse matrices. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)add</span></code> sums two sparse matrices and returns the result as a newly allocated sparse matrix for real and complex types, respectively. It performs the following operation: <div class="math notranslate nohighlight">
\[ C = \alpha * op ( A ) + B \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix and <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix if op = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <span class="math notranslate nohighlight">\(n \times m\)</span> otherwise and the result matrix <span class="math notranslate nohighlight">\(C\)</span> has the same dimension as <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only matrices in CSR format are supported in this release.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar with same precision as <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrix </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(B\)</span></p></li>
<li><p><strong>*C</strong> – <strong>[out]</strong> pointer to the sparse output matrix <span class="math notranslate nohighlight">\(C\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> or <code class="docutils literal notranslate"><span class="pre">C</span></code> are invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not compatible. </p></li>
<li><p><strong>aoclsparse_status_memory_error</strong> – Memory allocation failure. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – Matrices are not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415aoclsparse_caddK20aoclsparse_operationK17aoclsparse_matrixK24aoclsparse_float_complexK17aoclsparse_matrixP17aoclsparse_matrix">
<span id="_CPPv315aoclsparse_caddK20aoclsparse_operationK17aoclsparse_matrixK24aoclsparse_float_complexK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="_CPPv215aoclsparse_caddK20aoclsparse_operationK17aoclsparse_matrixK24aoclsparse_float_complexK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="aoclsparse_cadd__aoclsparse_operationC.aoclsparse_matrixC.aoclsparse_float_complexC.aoclsparse_matrixC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1a84d9da84f9f46df4021b161c0d376ef1"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_cadd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_float_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415aoclsparse_caddK20aoclsparse_operationK17aoclsparse_matrixK24aoclsparse_float_complexK17aoclsparse_matrixP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Addition of two sparse matrices. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)add</span></code> sums two sparse matrices and returns the result as a newly allocated sparse matrix for real and complex types, respectively. It performs the following operation: <div class="math notranslate nohighlight">
\[ C = \alpha * op ( A ) + B \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix and <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix if op = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <span class="math notranslate nohighlight">\(n \times m\)</span> otherwise and the result matrix <span class="math notranslate nohighlight">\(C\)</span> has the same dimension as <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only matrices in CSR format are supported in this release.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar with same precision as <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrix </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(B\)</span></p></li>
<li><p><strong>*C</strong> – <strong>[out]</strong> pointer to the sparse output matrix <span class="math notranslate nohighlight">\(C\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> or <code class="docutils literal notranslate"><span class="pre">C</span></code> are invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not compatible. </p></li>
<li><p><strong>aoclsparse_status_memory_error</strong> – Memory allocation failure. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – Matrices are not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv415aoclsparse_zaddK20aoclsparse_operationK17aoclsparse_matrixK25aoclsparse_double_complexK17aoclsparse_matrixP17aoclsparse_matrix">
<span id="_CPPv315aoclsparse_zaddK20aoclsparse_operationK17aoclsparse_matrixK25aoclsparse_double_complexK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="_CPPv215aoclsparse_zaddK20aoclsparse_operationK17aoclsparse_matrixK25aoclsparse_double_complexK17aoclsparse_matrixP17aoclsparse_matrix"></span><span id="aoclsparse_zadd__aoclsparse_operationC.aoclsparse_matrixC.aoclsparse_double_complexC.aoclsparse_matrixC.aoclsparse_matrixP"></span><span class="target" id="aoclsparse__functions_8h_1ab8b20f5be69b7ff00dece412b6f729d5"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_zadd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">aoclsparse_double_complex</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">alpha</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">B</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">C</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv415aoclsparse_zaddK20aoclsparse_operationK17aoclsparse_matrixK25aoclsparse_double_complexK17aoclsparse_matrixP17aoclsparse_matrix" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Addition of two sparse matrices. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_(s/d/c/z)add</span></code> sums two sparse matrices and returns the result as a newly allocated sparse matrix for real and complex types, respectively. It performs the following operation: <div class="math notranslate nohighlight">
\[ C = \alpha * op ( A ) + B \]</div>
 with <div class="math notranslate nohighlight">
\[\begin{split} op(A) = \left\{ \begin{array}{ll} A, &amp; \text{if op} = \text{aoclsparse\_operation\_none} \\ A^T, &amp; \text{if op} = \text{aoclsparse\_operation\_transpose} \\ A^H, &amp; \text{if op} = \text{aoclsparse\_operation\_conjugate\_transpose} \end{array} \right. \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(A\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix and <span class="math notranslate nohighlight">\(B\)</span> is a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix if op = <a class="reference internal" href="types.html#aoclsparse__types_8h_1a06e56a193abc969ee87838d433458bb2ad2b0fad42ea98866a8479cd1e356167e"><span class="std std-ref">aoclsparse_operation_none</span></a> and <span class="math notranslate nohighlight">\(n \times m\)</span> otherwise and the result matrix <span class="math notranslate nohighlight">\(C\)</span> has the same dimension as <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only matrices in CSR format are supported in this release.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix <span class="math notranslate nohighlight">\(A\)</span> operation type. </p></li>
<li><p><strong>alpha</strong> – <strong>[in]</strong> scalar with same precision as <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> matrix </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(A\)</span></p></li>
<li><p><strong>B</strong> – <strong>[in]</strong> source sparse matrix <span class="math notranslate nohighlight">\(B\)</span></p></li>
<li><p><strong>*C</strong> – <strong>[out]</strong> pointer to the sparse output matrix <span class="math notranslate nohighlight">\(C\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – The operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">A</span></code> or <code class="docutils literal notranslate"><span class="pre">B</span></code> or <code class="docutils literal notranslate"><span class="pre">C</span></code> are invalid </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – The dimensions of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code> are not compatible. </p></li>
<li><p><strong>aoclsparse_status_memory_error</strong> – Memory allocation failure. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – Matrices are not in CSR format. </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this heading">#</a></h2>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424aoclsparse_dilu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPdPKdPdPKd">
<span id="_CPPv324aoclsparse_dilu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPdPKdPdPKd"></span><span id="_CPPv224aoclsparse_dilu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPdPKdPdPKd"></span><span id="aoclsparse_dilu_smoother__aoclsparse_operation.aoclsparse_matrix.aoclsparse_mat_descrC.doublePP.doubleCP.doubleP.doubleCP"></span><span class="target" id="aoclsparse__functions_8h_1a829041e8014139d378082ca4337f5d3c"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_dilu_smoother</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">precond_csr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">approx_inv_diag</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424aoclsparse_dilu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPdPKdPdPKd" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse Iterative solver algorithms for single and double precision datatypes. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_ilu_smoother</span></code> performs Incomplete LU factorization on the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, defined in CSR storage format and also does an iterative LU solve to find an approximate <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<p>
For a usage example, see the ILU example in <code class="docutils literal notranslate"><span class="pre">tests/include</span></code> folder. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> operation type. Transpose not yet supported. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix handle. Currently ILU functionality is supported only for CSR matrix format. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix handle <code class="docutils literal notranslate"><span class="pre">A</span></code>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> is supported. Both, base-zero and base-one input arrays of CSR matrix are supported </p></li>
<li><p><strong>precond_csr_val</strong> – <strong>[out]</strong> output pointer that contains L and U factors after ILU operation. The original value buffer of matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not overwritten with the factors. </p></li>
<li><p><strong>approx_inv_diag</strong> – <strong>[in]</strong> It is unused as of now. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> element vector found using the known values of CSR matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> and resultant vector product <code class="docutils literal notranslate"><span class="pre">b</span></code> in <span class="math notranslate nohighlight">\(Ax = b\)</span>. Every call to the API gives an iterative update of <code class="docutils literal notranslate"><span class="pre">x</span></code>, whcih is used to find norm during LU solve phase. Norm and Relative Error % decides the convergence of <code class="docutils literal notranslate"><span class="pre">x</span></code> with respect to <code class="docutils literal notranslate"><span class="pre">x_ref</span></code></p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements which is the result of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in <span class="math notranslate nohighlight">\(Ax = b\)</span>. <code class="docutils literal notranslate"><span class="pre">b</span></code> is calculated using a known reference <code class="docutils literal notranslate"><span class="pre">x</span></code> vector, which is then used to find the norm for iterative <code class="docutils literal notranslate"><span class="pre">x</span></code> during LU solve phase. Norm and Relative Error percentage decides the convergence</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – input parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> or input matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424aoclsparse_silu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPfPKfPfPKf">
<span id="_CPPv324aoclsparse_silu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPfPKfPfPKf"></span><span id="_CPPv224aoclsparse_silu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPfPKfPfPKf"></span><span id="aoclsparse_silu_smoother__aoclsparse_operation.aoclsparse_matrix.aoclsparse_mat_descrC.floatPP.floatCP.floatP.floatCP"></span><span class="target" id="aoclsparse__functions_8h_1af9841a9244905b93a7a975f9e56f61f9"></span><a class="reference internal" href="types.html#_CPPv417aoclsparse_status" title="aoclsparse_status"><span class="n"><span class="pre">aoclsparse_status</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">aoclsparse_silu_smoother</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="types.html#_CPPv420aoclsparse_operation" title="aoclsparse_operation"><span class="n"><span class="pre">aoclsparse_operation</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">op</span></span>, <a class="reference internal" href="types.html#_CPPv417aoclsparse_matrix" title="aoclsparse_matrix"><span class="n"><span class="pre">aoclsparse_matrix</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="types.html#_CPPv420aoclsparse_mat_descr" title="aoclsparse_mat_descr"><span class="n"><span class="pre">aoclsparse_mat_descr</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">descr</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">precond_csr_val</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">approx_inv_diag</span></span>, <span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">float</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv424aoclsparse_silu_smoother20aoclsparse_operation17aoclsparse_matrixK20aoclsparse_mat_descrPPfPKfPfPKf" title="Permalink to this definition">#</a><br /></dt>
<dd><p>Sparse Iterative solver algorithms for single and double precision datatypes. </p>
<p><code class="docutils literal notranslate"><span class="pre">aoclsparse_ilu_smoother</span></code> performs Incomplete LU factorization on the sparse matrix <code class="docutils literal notranslate"><span class="pre">A</span></code>, defined in CSR storage format and also does an iterative LU solve to find an approximate <code class="docutils literal notranslate"><span class="pre">x</span></code></p>
<p>
For a usage example, see the ILU example in <code class="docutils literal notranslate"><span class="pre">tests/include</span></code> folder. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>op</strong> – <strong>[in]</strong> matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> operation type. Transpose not yet supported. </p></li>
<li><p><strong>A</strong> – <strong>[in]</strong> sparse matrix handle. Currently ILU functionality is supported only for CSR matrix format. </p></li>
<li><p><strong>descr</strong> – <strong>[in]</strong> descriptor of the sparse matrix handle <code class="docutils literal notranslate"><span class="pre">A</span></code>. Currently, only <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> is supported. Both, base-zero and base-one input arrays of CSR matrix are supported </p></li>
<li><p><strong>precond_csr_val</strong> – <strong>[out]</strong> output pointer that contains L and U factors after ILU operation. The original value buffer of matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not overwritten with the factors. </p></li>
<li><p><strong>approx_inv_diag</strong> – <strong>[in]</strong> It is unused as of now. </p></li>
<li><p><strong>x</strong> – <strong>[out]</strong> array of <code class="docutils literal notranslate"><span class="pre">n</span></code> element vector found using the known values of CSR matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> and resultant vector product <code class="docutils literal notranslate"><span class="pre">b</span></code> in <span class="math notranslate nohighlight">\(Ax = b\)</span>. Every call to the API gives an iterative update of <code class="docutils literal notranslate"><span class="pre">x</span></code>, whcih is used to find norm during LU solve phase. Norm and Relative Error % decides the convergence of <code class="docutils literal notranslate"><span class="pre">x</span></code> with respect to <code class="docutils literal notranslate"><span class="pre">x_ref</span></code></p></li>
<li><p><strong>b</strong> – <strong>[in]</strong> array of <code class="docutils literal notranslate"><span class="pre">m</span></code> elements which is the result of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code> in <span class="math notranslate nohighlight">\(Ax = b\)</span>. <code class="docutils literal notranslate"><span class="pre">b</span></code> is calculated using a known reference <code class="docutils literal notranslate"><span class="pre">x</span></code> vector, which is then used to find the norm for iterative <code class="docutils literal notranslate"><span class="pre">x</span></code> during LU solve phase. Norm and Relative Error percentage decides the convergence</p></li>
</ul>
</dd>
<dt class="field-even">Return values</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>aoclsparse_status_success</strong> – the operation completed successfully. </p></li>
<li><p><strong>aoclsparse_status_invalid_size</strong> – input parameters contain an invalid value. </p></li>
<li><p><strong>aoclsparse_status_invalid_pointer</strong> – <code class="docutils literal notranslate"><span class="pre">descr</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> is invalid. </p></li>
<li><p><strong>aoclsparse_status_not_implemented</strong> – <a class="reference internal" href="types.html#aoclsparse__types_8h_1afaf7a147466a2aa60419e3ae696377b6"><span class="std std-ref">aoclsparse_matrix_type</span></a> is not <a class="reference internal" href="types.html#aoclsparse__types_8h_1a5c171673227ff31121c2e27605f9735ea3c450405badd2dca9c5a99b00e9034a3"><span class="std std-ref">aoclsparse_matrix_type_symmetric</span></a> or input matrix <code class="docutils literal notranslate"><span class="pre">A</span></code> is not in CSR format</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  <!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="convert.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">AOCL-Sparse Conversion Subprogram</p>
      </div>
    </a>
    <a class="right-next"
       href="solvers.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">AOCL-Sparse Iterative Linear System Solvers</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-1">Level 1</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-2">Level 2</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#level-3">Level 3</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#miscellaneous">Miscellaneous</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            <p>
  </p>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=ac02cc09edc035673794"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=ac02cc09edc035673794"></script>

<footer class="rocm-footer">
    <div class="container-lg">
        <section class="bottom-menu menu py-45">
            <div class="row d-flex align-items-center">
                <div class="col-12 text-center">
                    <ul>
                        <li><a href="https://www.amd.com/en/corporate/copyright" target="_blank">Terms and Conditions</a></li>
                        
                        <li><a href="">2020-2024, Advanced Micro Devices, Inc</a></li>
                        <li><a href="https://www.amd.com/en/corporate/privacy" target="_blank">Privacy</a></li>
                        <li><a href="https://www.amd.com/en/corporate/trademarks" target="_blank">Trademarks</a></li>
                        <li><a href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf" target="_blank">Statement on Forced Labor</a></li>
                        <li><a href="https://www.amd.com/en/corporate/competition" target="_blank">Fair and Open Competition</a></li>
                        <li><a href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf" target="_blank">UK Tax Strategy</a></li>
                        <li><a href="https://www.amd.com/en/corporate/cookies" target="_blank">Cookie Policy</a></li>
                        <!-- OneTrust Cookies Settings button start -->
                        <li><a href="#cookie-settings" id="ot-sdk-btn" class="ot-sdk-show-settings">Cookie Settings</a></li>
                        <!-- OneTrust Cookies Settings button end -->
                    </ul>
                </div>
            </div>
            <div class="row d-flex align-items-center">
                <div class="col-12 text-center">
                    <div>
                        <span class="copyright">© 2023 Advanced Micro Devices, Inc</span>
                    </div>
                </div>
            </div>
        </section>
    </div>
</footer>

<!-- <div id="rdc-watermark-container">
    <img id="rdc-watermark" src="_static/images/alpha-watermark.svg" alt="DRAFT watermark"/>
</div> -->
  </body>
</html>